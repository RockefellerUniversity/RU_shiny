<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to Shiny, Session 1</title>
    <meta charset="utf-8" />
    <meta name="author" content="http://rockefelleruniversity.github.io/RU_course_template/" />
    <meta name="author" content="brc@rockefeller.edu" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link rel="stylesheet" href="default.css" type="text/css" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: middle, inverse, title-slide

.title[
# Introduction to Shiny, Session 1
]
.subtitle[
## <html><br />
<br />
<hr color='#EB811B' size=1px width=796px><br />
</html><br />
Bioinformatics Resource Center - Rockefeller University
]
.author[
### <a href="http://rockefelleruniversity.github.io/RU_course_template/" class="uri">http://rockefelleruniversity.github.io/RU_course_template/</a>
]
.author[
### <a href="mailto:brc@rockefeller.edu" class="email">brc@rockefeller.edu</a>
]

---






## Overview

??We often put an overview slide that links to the various parts of the course content to make it easy to navigate i.e. this one for intro to r??

- [Set up](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#set-up)
- [Background to R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#background-to-r)
- [Data types in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#data_types_in_r)
- [Reading and writing in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#reading-and-writing-data-in-r)

---
class: inverse, center, middle

# Set Up

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Materials

??We try to denote each major section of content with these title slides (see above for set up). The hierarchy will help with the different versions of the teaching content i.e. slides and single page.??

?? Materials just gives the links to download the package Just ensure links are up to date??

All prerequisites, links to material and slides for this course can be found on github.

* [Intro_To_R_1](https://rockefelleruniversity.github.io/Intro_To_R_1Day/)

Or can be downloaded as a zip archive from here.

* [Download zip](https://github.com/rockefelleruniversity/Intro_To_R_1Day/zipball/master)



---
## Course materials

?? this slide just shows where thye can get the course content from the download. You do not need to populate these directories. It will be made during compilation??

Once the zip file in unarchived. All presentations as HTML slides and pages, their R code and HTML practical sheets will be available in the directories underneath.

* **r_course/presentations/slides/**
Presentations as an HTML slide show.
* **r_course/presentations/singlepage/** 
Presentations as an HTML single page.
* **r_course/presentations/r_code/**
R code in presentations.
* **r_course/exercises/**
Practicals as HTML pages. 
* **r_course/answers/**
Practicals with answers as HTML pages and R code solutions. 



---
## Set the Working directory


Before running any of the code in the practicals or slides we need to set the working directory to the folder we unarchived. 

You may navigate to the unarchived RU_Course_help folder in the Rstudio menu.

**Session -&gt; Set Working Directory -&gt; Choose Directory**

or in the console.


``` r
setwd("/PathToMyDownload/RU_Course_template/r_course")
# e.g. setwd("~/Downloads/Intro_To_R_1Day/r_course")
```


---
class: inverse, center, middle

## What is Shiny? &lt;br&gt; Why do we use it?

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---





---


## Basic componenets of Shiny app
A shiny app consists of the user interface (UI) and the server function
* the UI object defines what will be seen on the page
* the server function contains code that combines R code with inputs (eg info from user, databases, or files) and provides instructions for generating outputs
* the *shinyApp* function builds the shiny app from the the UI object and server function

&lt;img src="imgs/shiny_ui_server.png"height="300" width="800"&gt;

Neth, H. (2025) *Introduction to Data Science* (https://bookdown.org/hneth/i2ds/)

---

## Shiny - how to get started

A Shiny app is generally contained within one R script to define the UI object and the server function.


``` r
library(shiny)
library(bslib)

ui = page_fluid(
  textOutput(outputId = "app_info")
)

server = function(input, output) {
  output$app_info = renderText("Our first app!")
}

shinyApp(ui = ui, server = server)
```
&lt;img src="imgs/first_app.png"height="400" width="500"&gt;


---

## Shiny - how to get started

When you run the *shinyApp* function, your RStudio console will be busy and you'll see a message with a URL. This is the port within your computer that the app is running. 

&lt;img src="imgs/listening_app.png"height="100" width="400"&gt;

A window should pop up automatically showing the app. You can also copy and paste this address into a browser to open an instance of the app. 

To close the app and free up the console, you can:
* click on the console to hit the *ESC* button or Ctrl+C
* click on the *Stop* button on the top right corner of the console

---

## Shiny - how to get started

Pretty much any Shiny app will start with the code below. Just paste this code into a fresh R script to get started.

TIP: Open a new R script, type *shinyapp*, then hit Shift+Tab, and the template will appear. 

Boiler plate Shiny app code:

``` r
library(shiny)

ui &lt;- page_fluid()

server &lt;- function(input, output, session) {
  
}

shinyApp(ui, server)
```


---

## Shiny - how to get started

Shiny is well integrated into R Studio and there are a few additional features that make running apps easier.

If you open a blank R script and add the shiny template code (see previous slide), once you save the file you should see a button in the upper right corner of the script that says *Run App*. 

This will automatically launch the app. 


&lt;img src="imgs/runApp_button_pp.png"height="200" width="800"&gt;

---

## Shiny - how to get started


How that app is launched (e.g. in browser or a window within RStudio) can be changed by the dropdown that is part of the *Run App* button


&lt;img src="imgs/runApp_dropdown.png"height="200" width="800"&gt;


---

## Shiny - how to get started

.pull-left[
You can also start a new app by opening a new file in R Studio and selecting the *Shiny Web App* option. 

The *Application name* you enter will be the name of a newly created directory that contains the app.R file and your Shiny app.

]

.pull-right[

&lt;img src="imgs/shiny_file_dropdown.png"height="400" width="350"&gt;
]
---


## Shiny resources for inputs and outputs 

The Shiny [cheatsheet](https://shiny.posit.co/r/articles/start/cheatsheet/) is a great resource demonstrating built-in input and output options

ADD IMAGE OF INPUTS FREOM CHEATSHEET!

or go through inputs like mastering shiny book

or go through the [posit widget gallery](https://shiny.posit.co/r/gallery/widgets/widget-gallery/)
---


## Build a basic app

**Talk about outputs and how outputs are paired with render functions**

``` r
ui = page_fluid(
  textOutput(outputId = "app_info")
)

print(as.character(ui))
```

```
## [1] "&lt;div class=\"container-fluid\"&gt;\n  &lt;div id=\"app_info\" class=\"shiny-text-output\"&gt;&lt;/div&gt;\n&lt;/div&gt;"
```

---

## Build a basic app

server function and launch app

``` r
server = function(input, output) {
  output$app_info = renderText("Our first app!")
}
```


``` r
shinyApp(ui = ui, server = server)
```

&lt;img src="imgs/basic.png"height="400" width="500"&gt;

---

## Adding global variables to app

Global variables can be assigned in the script outside of the UI object and server function. This code is run once upon initiating the app and global variables and settings are available within the app.


``` r
# read in table
#de_table &lt;- read.csv("shPTBP1_vs_control_DEG.csv")
de_table &lt;- read.csv("data/shP53_vs_control_DEG.csv")
de_table$negLog10_pval &lt;- -log10(de_table$pvalue)

# view table (would not be part of shiny script)
head(de_table, 3)
```

```
##                ID Symbol baseMean log2FoldChange      lfcSE      stat pvalue
## 1 ENSG00000002745  WNT16 1531.822      -3.766480 0.08955896 -42.05587      0
## 2 ENSG00000026025    VIM 1578.109       5.556894 0.12318261  45.11103      0
## 3 ENSG00000104419  NDRG1 6651.576      -3.614629 0.07273378 -49.69671      0
##   padj negLog10_pval
## 1    0           Inf
## 2    0           Inf
## 3    0           Inf
```

---

## App with datatable from DT package

UI object - add the table using the *dataTableOutput* function from the DT package

``` r
library(DT)

ui_simple = page_fluid(
  
  textOutput(outputId = "app_info"),
  
  DT::DTOutput(outputId = "de_data")
)
```

---

## App with datatable from DT package

Make the server function and launch app

Here we use the *renderDataTable* function, which will put the table in the UI where we specified with the *dataTableOutput* function

``` r
server_simple = function(input, output) {
  output$app_info = renderText("This is an app showing differential gene expression data")
  
  output$de_data = renderDataTable({
    datatable(de_table) 
  })
}
```



---

## App with datatable from DT package


``` r
shinyApp(ui = ui_simple, server = server_simple)
```
&lt;img src="imgs/addDT.png"height="350" width="750"&gt;

---

## Customize datatable

The DT package allows for a lot of customization of the html datatable. [This link](https://rstudio.github.io/DT/) shows some of the capabilities. 

Below we will add custom filters on top of each column and round the values to improve the appearance. 


``` r
server_simple2 = function(input, output) {
  output$app_info = renderText("This is an app showing differential gene expression data")
  
  output$de_data = renderDataTable({
    datatable(de_table,
              filter = 'top') %&gt;%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %&gt;%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
}
```



---

## Customize datatable


``` r
shinyApp(ui = ui_simple, server = server_simple2)
```
&lt;img src="imgs/customizeDT.png"height="350" width="750"&gt;

---

## Other options for displaying tables

  * [rhandsontable](https://jrowen.github.io/rhandsontable/) - based on javascript handsontable
    + an excel like table that is easily editable by the user
  * [reactable](https://glin.github.io/reactable/) - based on java script React Table
    + similar to DT. depends on use case.  

---

## Add plots to app

Add an MA plot and a Volcano plot to the page. First add the outputs to the UI object


``` r
ui_data = page_fluid(
  textOutput(outputId = "app_info"),
  
  dataTableOutput(outputId = "de_data"),
  
  plotOutput("ma_plot"),
  
  plotOutput("volcano_plot")
)
```

---

## Add plots to app

Then make the server function containing the *render* functions that tell shiny how to make the outputs from the IU object.


``` r
server_data = function(input, output) {
  output$app_info = renderText("This is an app showing differential gene expression data")
  
  output$de_data = renderDataTable({
    datatable(de_table,filter = 'top') %&gt;%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %&gt;%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  output$ma_plot = renderPlot({
    ggplot(de_table, aes(x = baseMean, y = log2FoldChange)) +
      geom_point() +
      scale_x_log10() +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })
  
  output$volcano_plot = renderPlot({
    ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
      geom_point() +
      theme_bw() +
      ggtitle("Volcano plot")
  })
}
```


---

## Add plots to app


``` r
shinyApp(ui = ui_data, server = server_data)
```

&lt;img src="imgs/addPlots.png"height="450" width="400"&gt;
---

class: inverse, center, middle

# App layouts

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Tidy up app appearance with cards

bslib has many functions that allow customizing the formatting of the page. Here we add 'cards', which are boxes that allow grouping of UI components


``` r
ui_fillable &lt;- page_fillable(

  card(card_header("Table of DE results"),
       dataTableOutput(outputId = "de_data")),
  card(card_header("MA plot"),
       plotOutput("ma_plot")),
  card(card_header("Volcano plot"),
       plotOutput("volcano_plot"))
)
```

---



## Tidy up app appearance with cards


``` r
#same server function as previous
shinyApp(ui = ui_fillable, server = server_data)
```

&lt;img src="imgs/addCards.png"height=450" width="400"&gt;

---

## Collapsable boxes with accordians

We can add the ability to hide certain boxes with accordians from the bslib package

``` r
ui_accordian &lt;- page_fillable(
  accordion(
    accordion_panel("Table of DE results",
                    dataTableOutput(outputId = "de_data")),
    
    accordion_panel("MA plot",
                    plotOutput("ma_plot")),
    
    accordion_panel("Volcano plot",
                    plotOutput("volcano_plot"))
  )
)
```

---

## Collapsable boxes with accordians


``` r
#same server function as previous
shinyApp(ui = ui_accordian, server = server_data)
```

&lt;img src="imgs/accordian.png"height="500" width="750"&gt;

---

## Collapsable boxes with accordians

Control over which panels can be opened initially can be set in the *accordian* function

``` r
ui_accordian &lt;- page_fillable(
  accordion(
    accordion_panel("Table of DE results",
                    dataTableOutput(outputId = "de_data")),
    
    accordion_panel("MA plot",
                    plotOutput("ma_plot")),
    
    accordion_panel("Volcano plot",
                    plotOutput("volcano_plot")),
    
    open = TRUE # will open all panels
  )
)
```

---

## Collapsable boxes with accordians


``` r
#same server function as previous
shinyApp(ui = ui_accordian, server = server_data)
```
&lt;img src="imgs/accordian_open.png"height="400" width="350"&gt;

---

## Customize layout with columns

The *layout_columns* function from bslib creates columns on the page

``` r
ui_column &lt;- page_fillable(
  layout_columns(
    col_widths = c(4,4,4),
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot")))
    )
  )
```

---

## Customize layout with columns


``` r
#same server function as previous
shinyApp(ui = ui_column, server = server_data)
```

&lt;img src="imgs/columns.png"height="450" width="750"&gt;
---

## Multiple rows
The 'col_widths' argument of the *layout_columns* function will control with width of the column. The bootstrap grid system is made up of 12 columns. A numeric vector is provided with widths for each card. Once the elements combined width goes above 12, then the elements are wrapped to the next row.

``` r
ui_twoRow &lt;- page_fillable(
  layout_columns(
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot"))),
    
    col_widths = c(12,6,6)
  ),
)
```

---

## Multiple rows


``` r
#same server function as previous
shinyApp(ui = ui_twoRow, server = server_data)
```

&lt;img src="imgs/multiple_rows.png"height="400" width="600"&gt;

---

## Page layout options

The previous app demonstrates how *page_fillable* will automatically fill the whole page (both vertically and horizontally). This can be controlled with the 'col_widths' and 'row_heights' arguments of the *layout_columns* function

bslib has two other options for the base of the page layout, *page_fixed* and *page_fluid*. The *page_fixed* function will use a fixed width that will vary based on the settings of the device, and the *page_fluid* function will extend to fill the whole width of the webpage. 

Both *page_fixed* and *page_fluid* will choose a sensible default height that can be set with the 'row_heights' argument of the *layout_columns* function. 

---

## Fixed page


``` r
ui_fixed &lt;- page_fixed(
  layout_columns(
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot"))),
    
    col_widths = c(12,6,6)
  )
)
```

---

## Fixed page


``` r
#same server function as previous
shinyApp(ui = ui_fixed, server = server_data)
```

&lt;img src="imgs/fixed_page.png"height="500" width="700"&gt;


---

## Fluid page


``` r
ui_fluid &lt;- page_fluid(
  layout_columns(
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot"))),
    
    col_widths = c(12,6,6)
  )
)
```


---

## Fluid page


``` r
#same server function as previous
shinyApp(ui = ui_fluid, server = server_data)
```

&lt;img src="imgs/fluid_page.png"height="400" width="550"&gt;

---
## Nested rows within a column

More complicated layouts can be achieved by nesting *layout_columns* functions. Here we add a tall card as a new row below the table and then nest the plots within this row next to the card. 


``` r
ui_nested &lt;- page_fluid(
  layout_columns(
    col_widths = 12,
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data")))),
  
  layout_columns(
    col_widths = 6,
    card(card_header("This is a tall box")),
    
    layout_columns(
      col_widths = c(12,12),
      card(card_header("MA plot",plotOutput("ma_plot"))),
      
      card(card_header("Volcano plot",plotOutput("volcano_plot")))
    )
  ),
)
```

---
## Nested rows within a column


``` r
#same server function as previous
shinyApp(ui = ui_nested, server = server_data)
```

&lt;img src="imgs/nested.png"height="400" width="500"&gt;

---

## Add a sidebar to the page

Sidebars are retractable and will remain static as you scroll up and down the page. They are often nice for user inputs or information that you always want the user to see. The width can be set within the function.


``` r
ui_sidebar &lt;- page_sidebar(
  title = "RNAseq tools",
  
  sidebar = sidebar(
    "This is a sidebar",
    width = 300,
  ),
  
  layout_columns(
    card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
    card(card_header("MA plot"),plotOutput("ma_plot")),
    card(card_header("Volcano plot"),plotOutput("volcano_plot")),
    col_widths = c(12,6,6), row_heights = c("750px", "500px")
  )
)
```

---

## Add a sidebar to the page

NOTE SHOW THAT YOU CAN ALSO ADD A SIDEBAR TO A CARD???


``` r
#same server function as previous
shinyApp(ui = ui_sidebar, server = server_data)
```

&lt;img src="imgs/sidebar.png"height="400" width="550"&gt;

---

## Use a navbar layout for multi-page app

# explain how you can have a side bar in one page or all pages!

``` r
ui_navbar &lt;- page_navbar(
  title = "RNAseq tools",
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)
```

---


## Use a navbar layout for multi-page app


``` r
#same server function as previous
shinyApp(ui = ui_navbar, server = server_data)
```

---
class: inverse, center, middle

# Themes

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


## Themes

It's easy to modify the look of the app using the bslib package. The *page_sidebar* function (and other payout functions) has a 'theme' argument that takes a *bs_theme* object.

bslib has builtin themes that can be easily used. The themes can be previewed (here)[https://bootswatch.com/], and the string to use in the 'bootswatch argument' of the *bs_theme* function can be picked from the vector returned by *bootswatch_themes()*


``` r
bootswatch_themes()
```

```
##  [1] "cerulean"  "cosmo"     "cyborg"    "darkly"    "flatly"    "journal"  
##  [7] "litera"    "lumen"     "lux"       "materia"   "minty"     "morph"    
## [13] "pulse"     "quartz"    "sandstone" "simplex"   "sketchy"   "slate"    
## [19] "solar"     "spacelab"  "superhero" "united"    "vapor"     "yeti"     
## [25] "zephyr"
```

---

## Themes - Cerulean


``` r
ui_cerulean &lt;- page_navbar(
  title = "RNAseq tools",
  theme = bs_theme(version = 5, bootswatch = "cerulean"),
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)
```

---

## Themes - Cerulean


``` r
#same server function as previous
shinyApp(ui = ui_cerulean, server = server_data)
```

---

## Themes - Darkly


``` r
ui_darkly &lt;- page_navbar(
  title = "RNAseq tools",
  theme = bs_theme(version = 5, bootswatch = "darkly"),
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)
```

---

## Themes - Darkly


``` r
#same server function as previous
shinyApp(ui = ui_darkly, server = server_data)
```

---

## Custom themes

A big benefit of the *bs_theme* function is the ability to highly customize the app theme. This can be done with the arguments to the function, or with additional CSS. We use custom CSS to modify the header of the cards throughout the app and manually set the main color options. 

``` r
custom_css &lt;- "
  .card-header {
    background-color: #d3dff1;
    border-bottom: 2px solid #273449;
  }
"

# Create theme with custom CSS
custom_theme &lt;- bs_theme(
  version = 5,
  bg = "white",
  fg = "#273449",
  primary = "#5886b2",
  secondary = "#95a5a6",
  success = "#18bc9c",
  info = "#3498db",
  warning = "#f39c12",
  danger = "#e74c3c",
  preset = "bootstrap",
  "navbar-bg" = "#5886b2"
) |&gt; bs_add_rules(custom_css)
```

---

## Custom themes

This custom theme object can then be used in the 'theme' argument of *page_sidebar*. 


``` r
ui_custom &lt;- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)
```
---

## Themes


``` r
#same server function as previous
shinyApp(ui = ui_custom, server = server_data)
```

---

class: inverse, center, middle

# Improving app experience - dynamic UIs and user feedback

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


## Using uiOutput/renderUI functions

.pull-left[
&lt;img src="imgs/mainApp_beforeUI_preupload.png"height="450" width="400"&gt;
]

.pull-right[
We still have empty boxes when the app starts even though we don't have any data to fill that space. There are also buttons  that don't do anything because there is no data yet. This is likely to be confusing for a user.

A nice way to deal with this is the *uiOutput* function, which allows you to change the user interface **after the app is running** based on other inputs or code in the server.

So far our user interface is set up at the start and while the contents might change based on other reactives, we haven't been able to make new inputs or outputs after the app has been started.
]


---
## Using uiOutput/renderUI functions

 
.pull-right[
&lt;img src="imgs/mainApp_beforeUI_filtBox.png"height="450" width="350"&gt;
]

.pull-left[
We could improve the flow of our app by making the filter inputs in the sidebar only appear once a user has loaded in a differential table. These filter inputs aren't relevant until the data is loaded, so we will only make them appear once the *de_table_in()* value is a dataframe, suggesting a file has been loaded and a table successfully read in.
]

---
## Using uiOutput/renderUI functions

The inputs for applying filters to our differential table are replaced with a *uiOutput* function call with an ID used in the output object in the server function This holds a location within the UI for us to eventually fill with server code.


``` r
ui_renderUI &lt;- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
*  uiOutput("sidebar_filters_UI"),
)

server_renderUI &lt;- function(input, output){
  de_table_in &lt;- reactive({
    req(input$de_file)
    rio::import(input$de_file$datapath) %&gt;% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$sidebar_filters_UI &lt;- renderUI({ 
    req(de_table_in())
      div(numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),
          numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
          actionButton("de_filter", "Apply filter"))
  })
}
```

---
## Using uiOutput/renderUI functions

These inputs are moved to the server within an output object paired with *renderUI* and are conditional on *de_table_in()* being a dataframe.


``` r
ui_renderUI &lt;- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
   uiOutput("sidebar_filters_UI"), 
)

server_renderUI &lt;- function(input, output){
  de_table_in &lt;- reactive({
    req(input$de_file)
    rio::import(input$de_file$datapath) %&gt;% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
* output$sidebar_filters_UI &lt;- renderUI({
*   req(de_table_in())
*   div(numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),
*       numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
*       actionButton("de_filter", "Apply filter"))
* })
}
```

---
## Using uiOutput/renderUI functions
EXPLAIN the DIV function!


---
## Launch uiOutput/renderUI app

``` r
shinyApp(ui = ui_renderUI, server = server_renderUI)
```

&lt;img src="imgs/filterInputs_renderUI.png"height="350" width="800"&gt;


---
## Using uiOutput/renderUI functions

We will also hide the tables and plots since they are of no use until a file is uploaded. Empty elements can confuse the user and make it seem like something is wrong.

maybe include image of full app previously to show the empty boxes?

---
## Using uiOutput/renderUI functions

Conditional UIs can also take advantage of more complex if statements to determine what is shown. In the example below, if not data frame is loaded, then we output a message for the user and once data is loaded, the table is shown.


``` r
ui_renderUI_table &lt;- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
  
* uiOutput("all_data_UI")
)

server_renderUI_table &lt;- function(input, output){
  de_table_in &lt;- reactive({
    req(input$de_file)
    rio::import(input$de_file$datapath) %&gt;% dplyr::mutate(negLog10_pval = -log10(pvalue))})
  
* output$all_data_UI &lt;- renderUI({
*   if(is.null(input$de_file)) {
*     div("You must load data!", style = "color: #273449; font-weight: bold;")
*   }else if(!is.null(de_table_in())){
*     navset_card_tab(nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data")))
*   }
* })
  
  output$all_data = renderDataTable(datatable(de_table_in()))
}
```

---
## Launch uiOutput/renderUI app

``` r
shinyApp(ui = ui_renderUI_table , server = server_renderUI_table)
```

&lt;img src="imgs/table_renderUI.png"height="350" width="800"&gt;

---
## Handling invalid input files

A common problem when allowing an input file is the likelihood a user uploads a file that causes an error in the app. Here we are looking for a table with speific columns, so we should confirm that the file is valid.

There are a few ways to do this in Shiny, and we will introduce a new Shiny function to handle this, the *validate* function.


``` r
shinyApp(ui = ui_renderUI_table , server = server_renderUI_table)
```

&lt;img src="imgs/bad_input_file.png"height="400" width="500"&gt;

---
## Use validate function to check input file

*Validate* prevents the alarming red error messages that are unhelpful to the user. This function can be used within a reactive expression, and the validation test is often called within a *need* function call.

*Need* takes an expression to evaluate, and if it is FALSE, then it will display a string provided in the 'message' argument in any output that depends on this reactive.

---
## Use validate function to check input file

We use *validate* in the server function when we read in the table. We check for the key columns in the table as we know that not having these columns will cause a downstream error in the app. 


``` r
ui_validate_small &lt;- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
  uiOutput("all_data_UI"))

server_validate_small &lt;- function(input, output){
  de_table_in &lt;- reactive({
    req(input$de_file)
    file_in &lt;- rio::import(input$de_file$datapath)
*   validate(
*     need(expr = all(c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj") %in% colnames(file_in)),
*          message = "You must have the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'"))
    file_in %&gt;% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data_UI &lt;- renderUI({
    if(is.null(input$de_file)) {
      div("You must load data!", style = "color: #273449; font-weight: bold;")
    }else if(!is.null(de_table_in())){ 
      navset_card_tab(nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data")))
      }
  })
  
  output$all_data = renderDataTable(datatable(de_table_in()))
}
```

---
## Use validate function to check input file

``` r
shinyApp(ui = ui_validate_small, server = server_validate_small)
```
&lt;img src="imgs/validate_small.png"height="300" width="800"&gt;

---
## Update main app

Recap of changes:
  * use *uiOutput/renderUI* to make the filter inputs and button from the sidebar conditional on the table being uploaded
  * use *uiOutput/renderUI* to display a message if there is not datapath loaded and only show the DE table one a valid table is read into the app.
  * add *validate* + *need* to the reactive expression where we read in the table from the user to make sure a valid inut file was used
  
  
---
## Update main app - UI


``` r
ui_renderUIall &lt;- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
        uiOutput("sidebar_filters_UI") # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
      ),
      uiOutput("table_plots_UI"), # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)
```

---
## Update main app - server



``` r
server_renderUIall = function(input, output) {
  
  de_table_in &lt;- reactive({
    req(input$de_file)
    file_in &lt;- rio::import(input$de_file$datapath)
    # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
    validate(
      need(expr = all(c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj") %in% colnames(file_in)), 
           message = "You must have the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'")
    )
    # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
    file_in %&gt;% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data = renderDataTable({
    datatable(de_table_in(), filter = 'top') %&gt;%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %&gt;%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })

  # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  output$table_plots_UI &lt;- renderUI({
    if(is.null(input$de_file)) { 
      layout_columns("No data has been loaded! Upload a DE table with the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'", style = "color: #273449; font-weight: bold;")
    }else if(!is.null(de_table_in())){ 
      layout_columns(
        navset_card_tab(
          title = "DE result tables",
          nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
          nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
        ),
        card(card_header("MA plot"),
             plotlyOutput("ma_plot"),
             downloadButton("download_ma_plot", "Download MA plot", style = "width:40%;")), 
        card(card_header("Volcano plot"),
             plotlyOutput("volcano_plot"),
             downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
      }
  })
  # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  
  # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  output$sidebar_filters_UI &lt;- renderUI({
    req(de_table_in())
      div(
        "DE filters",
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),
        
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
        
        actionButton("de_filter", "Apply filter")
      )
  })
  # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  
  filtered_de &lt;- reactive({
    de_table_in() %&gt;% 
      dplyr::filter(padj &lt; input$padj_filter &amp; abs(log2FoldChange) &gt; input$lfc_filter)
  }) %&gt;%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE)

  output$download_ma_plot &lt;- downloadHandler(
    filename = function() {
      "maplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = ma_plot_reac())
    }
  )
  
  output$download_volcano_plot &lt;- downloadHandler(
    filename = function() {
      "volcanoplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = volcano_plot_reac())
    }
  )
  
  output$de_data = renderDataTable({
    datatable(filtered_de(),
              filter = 'top') %&gt;%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %&gt;%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
    ma_plot_reac &lt;- reactive({
      de_table_in() %&gt;% 
      dplyr::mutate(sig = ifelse(padj &lt; input$padj_filter &amp; abs(log2FoldChange) &gt; input$lfc_filter, "DE", "Not_DE")) %&gt;%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig, label = Symbol)) + geom_point() +
      scale_x_log10() + scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") + theme_bw() + ggtitle("MA plot")
  })  %&gt;%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 

    output$ma_plot = renderPlotly({
      ggplotly(ma_plot_reac())
    }) 
  
    volcano_plot_reac &lt;- reactive({
        de_table_in() %&gt;% 
          dplyr::mutate(sig = ifelse(padj &lt; input$padj_filter &amp; abs(log2FoldChange) &gt; input$lfc_filter, "DE", "Not_DE")) %&gt;%
          ggplot(aes(x = log2FoldChange, y = negLog10_pval, color = sig)) +
          geom_point() +
          scale_color_manual(name = "DE status", values = c("red","grey"),) +
          theme_bw() +
          ggtitle("Volcano plot")
      
    }) %&gt;%
      bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 
  
    output$volcano_plot = renderPlotly({
      ggplotly(volcano_plot_reac())
    })
  
}
```

---
## Update main app - launch

``` r
shinyApp(ui = ui_renderUIall, server = server_renderUIall)
```


---

class: inverse, center, middle

# Observers

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Observers

Sometimes we might want our app to react to a change in an input, but we don't need to return a value like *reactive* or we don't need to change one of the outputs. Maybe we want to write to a database when a button is clicked, or notify the user that something has happened. 

Often the *observe* function is used for this purpose, to perform a side effect when an input changes.

Like the *reactive* function or an output, *observe* creates a reactive context that takes dependencies on inputs. Though unlike a reactive expression, an observer does not return a value and is eager in its evaluation, meaning it will evaluate the code every time an input it depends on changes. 

---

## Observers - notification for user

We will add a nice message for the user to notify them that a new data set has been loaded.

To do this we use the Shiny function *showNotification*. This takes text that will be the message, a duration in seconds for the notification to remain open, and a 'type' argument, which will control the color. We set 'duration' to be NULL, which means the user will have to click to close the notification, guaranteeing they will see it.

This function is within an *observe* function call in the server and takes a dependency on the input table with *bindEvent*. Notice we don't set the result to be a variable because an observer returns nothing, it just runs the code it contains. 

---

## Observers - notification for user


``` r
ui_notify &lt;- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
  uiOutput("all_data_UI"))

server_notify &lt;- function(input, output){
  de_table_in &lt;- reactive({
    req(input$de_file)
    file_in &lt;- rio::import(input$de_file$datapath)
  })
  
* observe({
*   showNotification("A new table has been loaded into the app!", duration = NULL, type = "message")
* }) %&gt;%
*   bindEvent(de_table_in())
  
  output$all_data_UI &lt;- renderUI({
    if(is.null(input$de_file)) {
      div("Load data!", style = "color: #273449; font-weight: bold;")
    }else{ navset_card_tab(nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))) }
  })
  
  output$all_data = renderDataTable(datatable(de_table_in()))
}
```

---
## Observers - notification for user

``` r
shinyApp(ui = ui_notify, server = server_notify)
```

&lt;img src="imgs/notify_small.png"height="350" width="700"&gt;


---

## Update app with notification - server 


``` r
server_notify = function(input, output) {
  
  # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  observe({
      showNotification("A new table has been loaded into the app!", duration = NULL, type = "message")
  }) %&gt;%
    bindEvent(de_table_in())
  # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  
  de_table_in &lt;- reactive({
    req(input$de_file)
    file_in &lt;- rio::import(input$de_file$datapath)
    validate(
      need(expr = all(c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj") %in% colnames(file_in)), 
           message = "You must have the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'")
    )
    file_in %&gt;% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data = renderDataTable({
    datatable(de_table_in(), filter = 'top') %&gt;%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %&gt;%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })

  output$table_plots_UI &lt;- renderUI({
    if(is.null(input$de_file)) { 
      layout_columns("No data has been loaded! Upload a DE table with the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'", style = "color: #273449; font-weight: bold;")
    }else if(!is.null(de_table_in())){ 
      layout_columns(
        navset_card_tab(
          title = "DE result tables",
          nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
          nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
        ),
        card(card_header("MA plot"),
             plotlyOutput("ma_plot"),
             downloadButton("download_ma_plot", "Download MA plot", style = "width:40%;")), 
        card(card_header("Volcano plot"),
             plotlyOutput("volcano_plot"),
             downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
      }
  })
  
  output$sidebar_filters_UI &lt;- renderUI({
    req(de_table_in())
      div(
        "DE filters",
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),
        
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
        
        actionButton("de_filter", "Apply filter")
      )
  })
  
  filtered_de &lt;- reactive({
    de_table_in() %&gt;% 
      dplyr::filter(padj &lt; input$padj_filter &amp; abs(log2FoldChange) &gt; input$lfc_filter)
  }) %&gt;%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE)

  output$download_ma_plot &lt;- downloadHandler(
    filename = function() {
      "maplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = ma_plot_reac())
    }
  )
  
  output$download_volcano_plot &lt;- downloadHandler(
    filename = function() {
      "volcanoplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = volcano_plot_reac())
    }
  )
  
  output$de_data = renderDataTable({
    datatable(filtered_de(),
              filter = 'top') %&gt;%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %&gt;%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
    ma_plot_reac &lt;- reactive({
      de_table_in() %&gt;% 
      dplyr::mutate(sig = ifelse(padj &lt; input$padj_filter &amp; abs(log2FoldChange) &gt; input$lfc_filter, "DE", "Not_DE")) %&gt;%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig, label = Symbol)) + geom_point() +
      scale_x_log10() + scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") + theme_bw() + ggtitle("MA plot")
  })  %&gt;%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 

    output$ma_plot = renderPlotly({
      ggplotly(ma_plot_reac())
    }) 
  
    volcano_plot_reac &lt;- reactive({
        de_table_in() %&gt;% 
          dplyr::mutate(sig = ifelse(padj &lt; input$padj_filter &amp; abs(log2FoldChange) &gt; input$lfc_filter, "DE", "Not_DE")) %&gt;%
          ggplot(aes(x = log2FoldChange, y = negLog10_pval, color = sig)) +
          geom_point() +
          scale_color_manual(name = "DE status", values = c("red","grey"),) +
          theme_bw() +
          ggtitle("Volcano plot")
      
    }) %&gt;%
      bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 
  
    output$volcano_plot = renderPlotly({
      ggplotly(volcano_plot_reac())
    })
}
```

---

## Notification for user - app

``` r
shinyApp(ui = ui_renderUIall, server = server_notify)
```

---
use observer to let user enter file name for plots?

also can use observer when you introduce the update* series of functions
---



# other ideas for later on

* reactiveValues()
* valueBox?
* intorduce ways to include custom HTML
* custom CSS?
* publishing to shinyapps.io
* debugging?
* mention shiny in python?


---
## Further Resources

* [Mastering Shiny book](https://mastering-shiny.org/index.html)
* [More widgets](https://dreamrs.github.io/shinyWidgets/)


---
## Exercises

Exercise on Reproducibility in R can be found [here](../../exercises/exercises/Docker_exercise.html)


---
## Contact

Any suggestions, comments, edits or questions (about content or the slides themselves) please reach out to our [GitHub](https://github.com/RockefellerUniversity/Intro_to_Shiny/issues) and raise an issue.


--
## Exercises
The following few slides show you how to structure exercise slides.

We often have several exercise slides per session. So you can just copy and paste and change the directory to the appropriate name. All 3 file types are made from you single exercise Rmd. 

---
## Time for an exercise!

??? exercise description here?? [here](../../exercises/exercises/shiny_exercise1_exercises.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/shiny_exercise1_answers.html)

R code for solutions can be found [here](../../exercises/answers/shiny_exercise1_answers.R)

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
