---
title: "Shiny, Session 1"
subtitle: " <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html> Bioinformatics Resource Center - Rockefeller University"
author: 
  - "http://rockefelleruniversity.github.io/RU_course_template/"
  - "brc@rockefeller.edu"
output: 
  xaringan::moon_reader:
    css: ["default.css", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      titleSlideClass: [middle, inverse]
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# Intro to Shiny

---
"    
  )
  
}

```

## Overview

??We often put an overview slide that links to the various parts of the course content to make it easy to navigate i.e. this one for intro to r??

- [Set up](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#set-up)
- [Background to R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#background-to-r)
- [Data types in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#data_types_in_r)
- [Reading and writing in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#reading-and-writing-data-in-r)

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Set Up

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Set Up

---
"    
  )
  
}

```

## Materials

??We try to denote each major section of content with these title slides (see above for set up). The hierarchy will help with the different versions of the teaching content i.e. slides and single page.??

?? Materials just gives the links to download the package Just ensure links are up to date??

All prerequisites, links to material and slides for this course can be found on github.

* [Intro_To_R_1](https://rockefelleruniversity.github.io/Intro_To_R_1Day/)

Or can be downloaded as a zip archive from here.

* [Download zip](https://github.com/rockefelleruniversity/Intro_To_R_1Day/zipball/master)



---
## Course materials

?? this slide just shows where thye can get the course content from the download. You do not need to populate these directories. It will be made during compilation??

Once the zip file in unarchived. All presentations as HTML slides and pages, their R code and HTML practical sheets will be available in the directories underneath.

* **r_course/presentations/slides/**
Presentations as an HTML slide show.
* **r_course/presentations/singlepage/** 
Presentations as an HTML single page.
* **r_course/presentations/r_code/**
R code in presentations.
* **r_course/exercises/**
Practicals as HTML pages. 
* **r_course/answers/**
Practicals with answers as HTML pages and R code solutions. 



---
## Set the Working directory


Before running any of the code in the practicals or slides we need to set the working directory to the folder we unarchived. 

You may navigate to the unarchived RU_Course_help folder in the Rstudio menu.

**Session -> Set Working Directory -> Choose Directory**

or in the console.

```{r setwd_introtoR,eval=F} 
setwd("/PathToMyDownload/RU_Course_template/r_course")
# e.g. setwd("~/Downloads/Intro_To_R_1Day/r_course")
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

## What is Shiny? <br> Why do we use it?

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("## What is Shiny? Why do we use it?

---
"    
  )
  
}

```



```{r, echo=F, eval=T, message = F}
library(shiny)
library(bslib)
library(ggplot2)
library(DT)

```

---


## Basic componenets of Shiny app
A shiny app consists of the user interface (UI) and the server function
* the UI object defines what will be seen on the page
* the server function contains code that combines R code with inputs (eg info from user, databases, or files) and provides instructions for generating outputs
* the *shinyApp* function builds the shiny app from the the UI object and server function

<img src="imgs/shiny_ui_server.png"height="300" width="800">

Neth, H. (2025) *Introduction to Data Science* (https://bookdown.org/hneth/i2ds/)

---

## Shiny - how to get started

A Shiny app is generally contained within one R script to define the UI object and the server function.

```{r first_app, echo=T, eval=F}
library(shiny)
library(bslib)

ui = page_fluid(
  textOutput(outputId = "app_info")
)

server = function(input, output) {
  output$app_info = renderText("Our first app!")
}

shinyApp(ui = ui, server = server)

```
<img src="imgs/first_app.png"height="400" width="500">


---

## Shiny - how to get started

When you run the *shinyApp* function, your RStudio console will be busy and you'll see a message with a URL. This is the port within your computer that the app is running. 

<img src="imgs/listening_app.png"height="100" width="400">

A window should pop up automatically showing the app. You can also copy and paste this address into a browser to open an instance of the app. 

To close the app and free up the console, you can:
* click on the console to hit the *ESC* button or Ctrl+C
* click on the *Stop* button on the top right corner of the console

---

## Shiny - how to get started

Pretty much any Shiny app will start with the code below. Just paste this code into a fresh R script to get started.

TIP: Open a new R script, type *shinyapp*, then hit Shift+Tab, and the template will appear. 

Boiler plate Shiny app code:
```{r template, eval=F, echo=T}
library(shiny)

ui <- page_fluid()

server <- function(input, output, session) {
  
}

shinyApp(ui, server)
```


---

## Shiny - how to get started

Shiny is well integrated into R Studio and there are a few additional features that make running apps easier.

If you open a blank R script and add the shiny template code (see previous slide), once you save the file you should see a button in the upper right corner of the script that says *Run App*. 

This will automatically launch the app. 


<img src="imgs/runApp_button_pp.png"height="200" width="800">

---

## Shiny - how to get started


How that app is launched (e.g. in browser or a window within RStudio) can be changed by the dropdown that is part of the *Run App* button


<img src="imgs/runApp_dropdown.png"height="200" width="800">


---

## Shiny - how to get started

.pull-left[
You can also start a new app by opening a new file in R Studio and selecting the *Shiny Web App* option. 

The *Application name* you enter will be the name of a newly created directory that contains the app.R file and your Shiny app.

]

.pull-right[

<img src="imgs/shiny_file_dropdown.png"height="400" width="350">
]
---


## Shiny resources for inputs and outputs 

The Shiny [cheatsheet](https://shiny.posit.co/r/articles/start/cheatsheet/) is a great resource demonstrating built-in input and output options

ADD IMAGE OF INPUTS FREOM CHEATSHEET!

or go through inputs like mastering shiny book

or go through the [posit widget gallery](https://shiny.posit.co/r/gallery/widgets/widget-gallery/)
---


## Build a basic app

**Talk about outputs and how outputs are paired with render functions**
```{r, echo=T, eval=T, out.width="75%"}
ui = page_fluid(
  textOutput(outputId = "app_info")
)

print(as.character(ui))
```

---

## Build a basic app

server function and launch app
```{r basic, echo=T, eval=T, out.width="75%"}


server = function(input, output) {
  output$app_info = renderText("Our first app!")
}

```

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui, server = server)
```

<img src="imgs/basic.png"height="400" width="500">

---

## Adding global variables to app

Global variables can be assigned in the script outside of the UI object and server function. This code is run once upon initiating the app and global variables and settings are available within the app.

```{r, echo=T, eval=T, out.width="75%"}
# read in table
#de_table <- read.csv("shPTBP1_vs_control_DEG.csv")
de_table <- read.csv("data/shP53_vs_control_DEG.csv")
de_table$negLog10_pval <- -log10(de_table$pvalue)

# view table (would not be part of shiny script)
head(de_table, 3)
```

---

## App with datatable from DT package

UI object - add the table using the *dataTableOutput* function from the DT package
```{r, echo=T, eval=T, out.width="75%"}
library(DT)

ui_simple = page_fluid(
  
  textOutput(outputId = "app_info"),
  
  DT::DTOutput(outputId = "de_data")
)


```

---

## App with datatable from DT package

Make the server function and launch app

Here we use the *renderDataTable* function, which will put the table in the UI where we specified with the *dataTableOutput* function
```{r, echo=T, eval=T, out.width="75%"}

server_simple = function(input, output) {
  output$app_info = renderText("This is an app showing differential gene expression data")
  
  output$de_data = renderDataTable({
    datatable(de_table) 
  })
}

```



---

## App with datatable from DT package

```{r addDT, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_simple, server = server_simple)
```
<img src="imgs/addDT.png"height="350" width="750">

---

## Customize datatable

The DT package allows for a lot of customization of the html datatable. [This link](https://rstudio.github.io/DT/) shows some of the capabilities. 

Below we will add custom filters on top of each column and round the values to improve the appearance. 

```{r, echo=T, eval=T, out.width="75%"}


server_simple2 = function(input, output) {
  output$app_info = renderText("This is an app showing differential gene expression data")
  
  output$de_data = renderDataTable({
    datatable(de_table,
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
}

```



---

## Customize datatable

```{r customizeDT, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_simple, server = server_simple2)
```
<img src="imgs/customizeDT.png"height="350" width="750">

---

## Other options for displaying tables

  * [rhandsontable](https://jrowen.github.io/rhandsontable/) - based on javascript handsontable
    + an excel like table that is easily editable by the user
  * [reactable](https://glin.github.io/reactable/) - based on java script React Table
    + similar to DT. depends on use case.  

---

## Add plots to app

Add an MA plot and a Volcano plot to the page. First add the outputs to the UI object

```{r, echo=T, eval=T, out.width="75%"}
ui_data = page_fluid(
  textOutput(outputId = "app_info"),
  
  dataTableOutput(outputId = "de_data"),
  
  plotOutput("ma_plot"),
  
  plotOutput("volcano_plot")
)

```

---

## Add plots to app

Then make the server function containing the *render* functions that tell shiny how to make the outputs from the IU object.

```{r, echo=T, eval=T, out.width="75%"}


server_data = function(input, output) {
  output$app_info = renderText("This is an app showing differential gene expression data")
  
  output$de_data = renderDataTable({
    datatable(de_table,filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  output$ma_plot = renderPlot({
    ggplot(de_table, aes(x = baseMean, y = log2FoldChange)) +
      geom_point() +
      scale_x_log10() +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })
  
  output$volcano_plot = renderPlot({
    ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
      geom_point() +
      theme_bw() +
      ggtitle("Volcano plot")
  })
}

```


---

## Add plots to app

```{r addPlots, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_data, server = server_data)
```

<img src="imgs/addPlots.png"height="450" width="400">
---

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# App layouts

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# App layouts

---
"    
  )
  
}

```

## Tidy up app appearance with cards

bslib has many functions that allow customizing the formatting of the page. Here we add 'cards', which are boxes that allow grouping of UI components

```{r, echo=T, eval=F, out.width="75%"}

ui_fillable <- page_fillable(

  card(card_header("Table of DE results"),
       dataTableOutput(outputId = "de_data")),
  card(card_header("MA plot"),
       plotOutput("ma_plot")),
  card(card_header("Volcano plot"),
       plotOutput("volcano_plot"))
)

```

---



## Tidy up app appearance with cards

```{r addCards, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_fillable, server = server_data)
```

<img src="imgs/addCards.png"height=450" width="400">

---

## Collapsable boxes with accordians

We can add the ability to hide certain boxes with accordians from the bslib package
```{r, echo=T, eval=F, out.width="75%"}

ui_accordian <- page_fillable(
  accordion(
    accordion_panel("Table of DE results",
                    dataTableOutput(outputId = "de_data")),
    
    accordion_panel("MA plot",
                    plotOutput("ma_plot")),
    
    accordion_panel("Volcano plot",
                    plotOutput("volcano_plot"))
  )
)

```

---

## Collapsable boxes with accordians

```{r accordian, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_accordian, server = server_data)
```

<img src="imgs/accordian.png"height="500" width="750">

---

## Collapsable boxes with accordians

Control over which panels can be opened initially can be set in the *accordian* function
```{r, echo=T, eval=F, out.width="75%"}

ui_accordian <- page_fillable(
  accordion(
    accordion_panel("Table of DE results",
                    dataTableOutput(outputId = "de_data")),
    
    accordion_panel("MA plot",
                    plotOutput("ma_plot")),
    
    accordion_panel("Volcano plot",
                    plotOutput("volcano_plot")),
    
    open = TRUE # will open all panels
  )
)

```

---

## Collapsable boxes with accordians

```{r, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_accordian, server = server_data)
```
<img src="imgs/accordian_open.png"height="400" width="350">

---

## Customize layout with columns

The *layout_columns* function from bslib creates columns on the page
```{r, echo=T, eval=F, out.width="75%"}

ui_column <- page_fillable(
  layout_columns(
    col_widths = c(4,4,4),
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot")))
    )
  )

```

---

## Customize layout with columns

```{r columns, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_column, server = server_data)
```

<img src="imgs/columns.png"height="450" width="750">
---

## Multiple rows
The 'col_widths' argument of the *layout_columns* function will control with width of the column. The bootstrap grid system is made up of 12 columns. A numeric vector is provided with widths for each card. Once the elements combined width goes above 12, then the elements are wrapped to the next row.
```{r, echo=T, eval=F, out.width="75%"}

ui_twoRow <- page_fillable(
  layout_columns(
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot"))),
    
    col_widths = c(12,6,6)
  ),
)

```

---

## Multiple rows

```{r multiple_rows, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_twoRow, server = server_data)
```

<img src="imgs/multiple_rows.png"height="400" width="600">

---

## Page layout options

The previous app demonstrates how *page_fillable* will automatically fill the whole page (both vertically and horizontally). This can be controlled with the 'col_widths' and 'row_heights' arguments of the *layout_columns* function

bslib has two other options for the base of the page layout, *page_fixed* and *page_fluid*. The *page_fixed* function will use a fixed width that will vary based on the settings of the device, and the *page_fluid* function will extend to fill the whole width of the webpage. 

Both *page_fixed* and *page_fluid* will choose a sensible default height that can be set with the 'row_heights' argument of the *layout_columns* function. 

---

## Fixed page

```{r, echo=T, eval=F, out.width="75%"}

ui_fixed <- page_fixed(
  layout_columns(
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot"))),
    
    col_widths = c(12,6,6)
  )
)

```

---

## Fixed page

```{r fixed_page, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_fixed, server = server_data)
```

<img src="imgs/fixed_page.png"height="500" width="700">


---

## Fluid page

```{r, echo=T, eval=F, out.width="75%"}

ui_fluid <- page_fluid(
  layout_columns(
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data"))),
    
    card(card_header("MA plot",plotOutput("ma_plot"))),
    
    card(card_header("Volcano plot",plotOutput("volcano_plot"))),
    
    col_widths = c(12,6,6)
  )
)

```


---

## Fluid page

```{r fluid_page, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_fluid, server = server_data)
```

<img src="imgs/fluid_page.png"height="400" width="550">

---
## Nested rows within a column

More complicated layouts can be achieved by nesting *layout_columns* functions. Here we add a tall card as a new row below the table and then nest the plots within this row next to the card. 

```{r, echo=T, eval=F, out.width="75%"}

ui_nested <- page_fluid(
  layout_columns(
    col_widths = 12,
    card(card_header("Table of DE results", dataTableOutput(outputId = "de_data")))),
  
  layout_columns(
    col_widths = 6,
    card(card_header("This is a tall box")),
    
    layout_columns(
      col_widths = c(12,12),
      card(card_header("MA plot",plotOutput("ma_plot"))),
      
      card(card_header("Volcano plot",plotOutput("volcano_plot")))
    )
  ),
)

```

---
## Nested rows within a column

```{r nested, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_nested, server = server_data)
```

<img src="imgs/nested.png"height="400" width="500">

---

## Add a sidebar to the page

Sidebars are retractable and will remain static as you scroll up and down the page. They are often nice for user inputs or information that you always want the user to see. The width can be set within the function.

```{r, echo=T, eval=T, out.width="75%"}

ui_sidebar <- page_sidebar(
  title = "RNAseq tools",
  
  sidebar = sidebar(
    "This is a sidebar",
    width = 300,
  ),
  
  layout_columns(
    card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
    card(card_header("MA plot"),plotOutput("ma_plot")),
    card(card_header("Volcano plot"),plotOutput("volcano_plot")),
    col_widths = c(12,6,6), row_heights = c("750px", "500px")
  )
)

```

---

## Add a sidebar to the page

NOTE SHOW THAT YOU CAN ALSO ADD A SIDEBAR TO A CARD???

```{r sidebar, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_sidebar, server = server_data)
```

<img src="imgs/sidebar.png"height="400" width="550">

---

## Use a navbar layout for multi-page app

# explain how you can have a side bar in one page or all pages!
```{r, echo=T, eval=T, out.width="75%"}

ui_navbar <- page_navbar(
  title = "RNAseq tools",
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```

---


## Use a navbar layout for multi-page app

```{r, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_navbar, server = server_data)
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Themes

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Themes

---
"    
  )
  
}

```


## Themes

It's easy to modify the look of the app using the bslib package. The *page_sidebar* function (and other payout functions) has a 'theme' argument that takes a *bs_theme* object.

bslib has builtin themes that can be easily used. The themes can be previewed (here)[https://bootswatch.com/], and the string to use in the 'bootswatch argument' of the *bs_theme* function can be picked from the vector returned by *bootswatch_themes()*

```{r}
bootswatch_themes()
```

---

## Themes - Cerulean

```{r, echo=T, eval=T, out.width="75%"}

ui_cerulean <- page_navbar(
  title = "RNAseq tools",
  theme = bs_theme(version = 5, bootswatch = "cerulean"),
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```

---

## Themes - Cerulean

```{r, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_cerulean, server = server_data)
```

---

## Themes - Darkly

```{r, echo=T, eval=T, out.width="75%"}

ui_darkly <- page_navbar(
  title = "RNAseq tools",
  theme = bs_theme(version = 5, bootswatch = "darkly"),
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```

---

## Themes - Darkly

```{r, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_darkly, server = server_data)
```

---

## Custom themes

A big benefit of the *bs_theme* function is the ability to highly customize the app theme. This can be done with the arguments to the function, or with additional CSS. We use custom CSS to modify the header of the cards throughout the app and manually set the main color options. 
```{r, echo=T, eval=T, out.width="75%"}

custom_css <- "
  .card-header {
    background-color: #d3dff1;
    border-bottom: 2px solid #273449;
  }
"

# Create theme with custom CSS
custom_theme <- bs_theme(
  version = 5,
  bg = "white",
  fg = "#273449",
  primary = "#5886b2",
  secondary = "#95a5a6",
  success = "#18bc9c",
  info = "#3498db",
  warning = "#f39c12",
  danger = "#e74c3c",
  preset = "bootstrap",
  "navbar-bg" = "#5886b2"
) |> bs_add_rules(custom_css)

```

---

## Custom themes

This custom theme object can then be used in the 'theme' argument of *page_sidebar*. 

```{r, echo=T, eval=T, out.width="75%"}

ui_custom <- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        "This is a sidebar",
        width = 300,
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```
---

## Themes

```{r, echo=T, eval=F, out.width="75%"}
#same server function as previous
shinyApp(ui = ui_custom, server = server_data)
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Inputs

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Inputs

---
"    
  )
  
}

```

## Inputs - text boxes

should probably explain in detail how the input functons work in general (Arguments, etc)
```{r text_boxes, echo=T, eval=F}
ui_textInputs = page_fluid(
  textInput(inputId = "text_box", label = "Experiment name:"),
  textAreaInput(inputId = "big_text_box", "Describe your experiment:", rows = 3)
)

```

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_textInputs, server = function(input, output){})
```

<img src="imgs/text_boxes.png"height="250" width="350">

---

## Inputs - dropdowns


```{r dropdowns, echo=T, eval=T}
ui_selInputs <- page_fluid(
  selectInput("dropdown", "Select a gene:", 
              choices = c("TP53", "PTEN", "HRAS", "PI3K")),
  
  selectInput("dropdown", "Select a gene from this really wide box!", 
              choices = c("TP53", "PTEN", "HRAS", "PI3K"),
              width = "100%"),
  
  selectInput("dropdown2", "Select more than one gene if you want:", 
              choices = c("TP53", "PTEN", "HRAS", "PI3K"), 
              selected = c("PTEN", "HRAS"), multiple = T),
)
```

---

## Inputs - dropdowns

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_selInputs, server = function(input, output){})
```

<img src="imgs/dropdowns.png"height="350" width="650">

---

## Inputs - selection of choices


```{r pickInputs, echo=T, eval=T}
ui_pickInputs <- page_fluid(

  "If you want the user to only select one option from a list, radioButtons work well",
  radioButtons("radio", "Select only one gene from the radio selections:", 
              choices = c("TP53", "PTEN", "HRAS", "PI3K"), 
              selected = "HRAS"),
  
  "To allow the user to select multiple options, use checkboxGroupInput",
  checkboxGroupInput("checkbox_group", "Check one or more boxes next to a gene:", 
                     choices = c("TP53", "PTEN", "HRAS", "PI3K")),

  "OR if you only want a binary yes/no, you can use checkboxInput",
  checkboxInput("checkbox", "Do you agree to the terms and conditions?"),
)

```

---

## Inputs - selection of choices

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_pickInputs, server = function(input, output){})
```

<img src="imgs/pickInputs.png"height="400" width="550">

---

## Inputs - numeric


```{r numInputs, echo=T, eval=T}
ui_numInputs <- page_fluid(
  
  numericInput("numeric", "Number of samples", value = 1, min = 0, max = 100),
  
  sliderInput("num_slider", "Number of samples", value = 10, min = 0, max = 25),
  
  sliderInput("num_slider", "Range of sample numbers", value = c(10,20), min = 0, max = 25)
)


```

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_numInputs, server = function(input, output){})
```

<img src="imgs/numInputs.png"height="250" width="350">

---

## Inputs - dates


```{r dateInputs, echo=T, eval=T}
ui_dateInputs <- page_fluid(
  dateInput("date", "Choose a date:"),
  
  dateRangeInput("date_range", "Choose a range of dates:")
)

```

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_dateInputs, server = function(input, output){})
```

<img src="imgs/dateInputs.png"height="300" width="250">

---

## Inputs - action buttons

To have the user trigger downstream events by clicking a button, we can use an *actionButton*
```{r, echo=T, eval=T}
ui_button <- page_fluid(
  actionButton("button", "Click me!"),
)

```

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_button, server = function(input, output){})
```
<img src="imgs/actionButton.png"height="100" width="250">


---

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Reactivity

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Reactivity

---
"    
  )
  
}

```

## Reactive use of inputs

We have seen many types of inputs, but these would be pointless if we can't detect when they change or know what is selected.

Every input returns some kind of value, and changes in this value can be recorded by shiny. This introduces the concept of 'reactivity', the key element of shiny that makes apps useful and cool.

---

## Using reactivity

If we include an output and it's corresponding render function that uses inputs we have created, we can see the return value of the input.

This is an example of simple reactivity, we change the gene, and the *gene_name* output detects this and displays the new gene name. 

```{r, echo=T, eval=T}
ui_gene <- page_fluid(
  radioButtons("gene", "Select only one gene from the radio selections:", 
              choices = c("TP53", "PTEN", "HRAS", "PI3K"), 
              selected = "HRAS"),
  
  textOutput("gene_text")
)

server_gene = function(input, output){
   output$gene_text <- renderText({
     paste0("We will study ", input$gene)
   })
 }

```



---

## Using reactivity

```{r, echo=T, eval=F, out.width="75%"}

shinyApp(ui = ui_gene, server = server_gene)
```

.pull-left[
<img src="imgs/hras.png"height="200" width="250">
]

.pull-right[

<img src="imgs/pi3k.png"height="200" width="250">
]

---

## Reactive graph

<img src="imgs/input_output.png"height="300" width="700">

---

## Reactive contexts

Inputs are considered a 'reactive value'. This means that when that value changes, anything that relies on this value will also change. 

The requires special handling, and a reactive value can only be used in certain contexts.  For example, we get an error if we just try and print *input$gene* without putting it inside a reactive handler, such as *renderText*. 

We will learn more about other reactive contexts later on. 
```{r, echo=T, eval=F}

server_geneBad = function(input, output){
    print(paste0("We will study ", input$gene))
 }

```

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_gene, server = server_geneBad)
```

<img src="imgs/reactive_error.png"height="65" width="500">

---

## Reactivity

Here is a slightly more complicated reactive situation where we have more than one input being used by an output, including a calculation involving two separate inputs.

```{r, echo=T, eval=T}
ui_gene2 <- page_fluid(
  radioButtons("gene", "Select only one gene from the radio selections:", 
              choices = c("TP53", "PTEN", "HRAS", "PI3K"), 
              selected = "HRAS"),
  
  sliderInput("conditions", "Number of samples", value = 10, min = 0, max = 25),
  
  numericInput("replicates", "Number of replicates", value = 1, min = 0, max = 100),
  
  textOutput("study_summary")
)

server_gene2 = function(input, output){
   output$study_summary <- renderText({
     paste0("We will study ", input$gene, " and use ", input$conditions, " samples, with ", input$replicates, " replicates of each. This will give ", input$conditions*input$replicates, " total samples.")
   })
 }

```

---

## Reactivity

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_gene2, server = server_gene2)
```

---

## Reactivity
 This sets up a reactive graph where we have one output, *output$study_summary*, that depends on three inputs and a separate calculation that involves the two numeric inputs. 

<img src="imgs/no_reactive_graph1.png"height="300" width="400">

---

## Reactivity

While this code will work, it is not the most efficient way to write this app. Because *output$study_summary* depends directly on the sample calculation, it will re-run it any time that **any one of these inputs change**, even if it is not involved in that calculation, such as *input$gene*. 

This is okay for this situation, but if a more intensive calculation was being done, this would slow the app considerably.

<img src="imgs/no_reactive_graph2.png"height="300" width="800">

---
## Lazy evaluation of reactive functions

A key aspect of reactivity in Shiny is that evaluation in a shiny app is generally 'lazy'. This means that any code in the app is only evaluated when it is needed, typically when a dependency changes. This is different than a typical R script that runs from top to bottom.

We will introduce a new shiny function that helps to make reactivity much more efficient and utilizes the advantage of lazy code evaluation in shiny. 

That would be the *reactive* function, which creates a reactive expression. A reactive expression usually takes inputs as dependencies and it's value is often used by an output.

<img src="imgs/reactive_intro.png"height="250" width="700">

---

## Reactive expressions

Key aspects of a reactive function:

  * It usually depends on one or more reactive inputs
  * If one of these dependencies changes, then it is invalidated and the next time that reactive expression is called it will be computed again.
  * The output of the function is cached and is available for use within the app. 
  * When the expression is called in the app and the value of a reactive function is valid, this value is retrieved without any further computation. 


---

## Reactive expressions

A *reactive* function takes a chunk of R code and returns a value like a regular R function. To use the result, use the name of the expression followed by parenthesis, e.g. total_samples() below. It will return the object made by the last line, or you can use the *return* function, just like any other function in R.

```{r, echo=T, eval=T}
server_geneGood = function(input, output){
  
  total_samples <- reactive({
    input$conditions*input$replicates
  })
  
   output$study_summary <- renderText({
     paste0("We will study ", input$gene, " and use ", input$conditions, " samples, with ", input$replicates, " replicates of each. This will give ", total_samples(), " total samples.")
   })
}

```

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_gene2, server = server_geneGood)
```


---
## Reactive expressions

Applied to our previous example, *output$study_summary* calls *total_samples()*, which takes dependencies on the two numeric inputs to make this calculation. 



<img src="imgs/reactivity_with_reactive1.png"height="300" width="500">

---
## Reactive expressions

*total_samples()* is only calculated if *input$conditions* or *input$replicates* has changed since the last time this text was rendered. 

If the *input$gene* is changed, then the cached value of *total_samples()* is used and it does not need to be re-calculated.

<img src="imgs/reactivity_with_reactive2.png"height="300" width="750">



---
## Reactive expressions

As a reminder, when this calculation was previously housed within the *renderText* function and not in a reactive expression, the total number of samples would be recalculated if *input$gene* changed, even though the calculation doesn't depend on it.  

<img src="imgs/no_reactive_graph2.png"height="300" width="800">

---
## Add reactivity to RNAseq app

Now we can use some of these inputs and reactivity to improve our RNAseq analysis app.

We have a blank sidebar, but this would be a good place to add some inputs to make our app more interactive.
```{r, echo=T, eval=F, out.width="75%"}
# sidebar app we previously made
shinyApp(ui = ui_custom, server = server_data)
```

<img src="imgs/sidebar.png"height="400" width="550">

---
## Add a filter for the DE table - UI object 

We can add numeric inputs for the user to add cutoff values for adjusted pvalue and log2 fold change.

In the UI we will add numeric inputs to allow the user to select the cut off values. We can set some sensible starting values as well using the 'value' argment of each function. 
```{r, echo=T, eval=T, results = 'hide'}
sidebar = sidebar(
  width = 300,
  numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.005),
  
  numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 0, min = 0, step = 0.1)
)
```

---
## Add a filter for the DE table - server 

If we were to launch the app after adding these inputs to the UI, the filters would appear, but nothing would happen when we change the values. We need to use these values in the app's server function.

We will add a reactive expression that will take these values and make a filtered version of the differential expression table.

```{r, echo=T, eval=T, results = 'hide'}
filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  })
```

We also need to use this reactive expression in the render* function that creates the table output. Remember, reactive expressions are used as if they are function calls with parenthesis.
```{r, echo=T, eval=F, results = 'hide'}
output$de_data = renderDataTable({
    datatable(filtered_de(),
              selection = "none",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
```




---
## Add the filter to the full app - UI


We include these inputs in the sidebar of the UI object.

```{r, echo=T, eval=T}

ui_filter <- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.005),
    
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 0, min = 0, step = 0.1)
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```

 


---
## Add the filter to the full app - server 

```{r, echo=T, eval=T, out.width="75%"}
server_filter = function(input, output){ 
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  })
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  output$de_data = renderDataTable({
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    datatable(filtered_de(),
              selection = "none", 
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  })
  
  output$ma_plot = renderPlot({
    ggplot(de_table, aes(x = baseMean, y = log2FoldChange)) +
      geom_point() +
      scale_x_log10() +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })
  
  output$volcano_plot = renderPlot({
    ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
      geom_point() +
      theme_bw() +
      ggtitle("Volcano plot")
  })
  
}

```

---
## Add a filter for the DE table 

```{r sidebar_DEfilter, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_filter, server = server_filter)
```

<img src="imgs/sidebar_DEfilter.png"height="600" width="650">

---
## Control filtering with a button

You'll notice the table is reacting in real time as we change the values. This might be what you want, but a cleaner solution could be to wait to apply the filter until the user explicitly wants to.

We can to this by pairing an *actionButton* with a new function, *bindEvent*. This modifies the reactive expression and instead of updating when any reactive value it depends on changes, it will only update based on a specific event (e.g. when a button is pressed)

<img src="imgs/de_app_button.png"height="300" width="400">

---
## Using a button to control filtering

The *actionButton* function is used in the UI object: 

```{r, echo=T, eval=T, results = 'hide'}
actionButton("de_filter", "Apply filter")
```

In the server function, we modify the reactive expression to be dependent on this button. We wrap the reactive (or add using a pipe) in the *bindEvent* function and include the dependency *input$de_filter* as the first argument. 

This will make this reactive expression only trigger when the button is pressed 
```{r, echo=T, eval=T, results = 'hide'}
filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter)
```


---
## Add button to app UI

```{r, echo=T, eval=T}

ui_filterButton <- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.005),
    
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        actionButton("de_filter", "Apply filter")
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      ),
      
      layout_columns(
        card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data")),
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```


---
## Add button to app server

```{r, echo=T, eval=T, out.width="75%"}
server_filterButton = function(input, output) {
  filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter) # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  output$de_data = renderDataTable({
    datatable(filtered_de(),
              selection = "none",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  output$ma_plot = renderPlot({
    ggplot(de_table, aes(x = baseMean, y = log2FoldChange)) +
      geom_point() +
      scale_x_log10() +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })
  
  output$volcano_plot = renderPlot({
    ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
      geom_point() +
      theme_bw() +
      ggtitle("Volcano plot")
  })
  
}

```


---
## Launch app with button

You'll notice that the table doesn't appear initially, and only appears once we click the button. By default, *bindEvent* does not run when a button still has a value of 0 (meaning it hasn't been clicked).

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_filterButton, server = server_filterButton)
```
<img src="imgs/button_ignoreNULL_issue.png"height="600" width="650">


---
## Initialize table before first button click

The *bindEvent* function has an argument 'ignoreNULL' that tells it whether to not update the reactive expression when the value is NULL, or 0 for an actionButton. We can turn this setting off and the reactive will update when the button initializes and has a value of 0.

```{r, echo=T, eval=T, out.width="75%"}
server_filterButton2 = function(input, output) {
  filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, ignoreNULL = FALSE) # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  output$de_data = renderDataTable({
    datatable(filtered_de(),
              selection = "none",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  output$ma_plot = renderPlot({
    ggplot(de_table, aes(x = baseMean, y = log2FoldChange)) +
      geom_point() +
      scale_x_log10() +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })
  
  output$volcano_plot = renderPlot({
    ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
      geom_point() +
      theme_bw() +
      ggtitle("Volcano plot")
  })
  
}

```

---
## Initialize table before first button click

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_filterButton, server = server_filterButton2)
```

<img src="imgs/button_ignoreNULL_resolved.png"height="600" width="650">

---
## Add a tab to a card - UI

Currently, we show the filtered table, but if we also want to give the user the full data as well, having mutliple tabs within the card can be a nice clean way to do this.

To do this, we change the card that we want to contain tabs to use the function *navset_card_tab*, which will then have multiple *nav_panel* function calls for each individual tab. 

Old card containing only one table (with filtered gene set):
```{r, echo=T, eval=T, results='hide'}
card(card_header("Table of DE results"), dataTableOutput(outputId = "de_data"))
```

New card with tabs:
```{r, echo=T, eval=T, results='hide'}
navset_card_tab(
  title = "DE result tables",
  
  nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
  
  nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
)
```

---
## Add a tab to a card - server

We then need to add a corresponding render function for the second tab containing the full table. 

This will be added to the server function:
```{r, echo=T, eval=F}
output$all_data = renderDataTable({
    datatable(de_table,
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
```


---
## Add a tab main app - UI

```{r, echo=T, eval=T}

ui_tab <- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.005),
    
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
 
        actionButton("de_filter", "Apply filter")
      ),
      # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      layout_columns(
        navset_card_tab(
          title = "DE result tables",
          nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
          nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
        ),
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        card(card_header("MA plot"),plotOutput("ma_plot")),
        card(card_header("Volcano plot"),plotOutput("volcano_plot")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```

---
## Add a tab main app - server

The output object and render function for the full data table are added to the server function. 

```{r, echo=T, eval=T, out.width="75%"}
server_tab = function(input, output) {
  
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  output$all_data = renderDataTable({
    datatable(de_table,
              selection = "none",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, ignoreNULL = FALSE)

  output$de_data = renderDataTable({
    datatable(filtered_de(),
              selection = "none",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  output$ma_plot = renderPlot({
    ggplot(de_table, aes(x = baseMean, y = log2FoldChange)) +
      geom_point() +
      scale_x_log10() +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })
  
  output$volcano_plot = renderPlot({
    ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
      geom_point() +
      theme_bw() +
      ggtitle("Volcano plot")
  })
  
}

```

---
## Launch app with tabs
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_tab, server = server_tab)
```

---
## Color the DE genes in plots

We can also make the plots responsive to the cutoffs by coloring the points that exceed the thresholds. 

Like the table, we will make the colors of the points dependent on the filter button. The UI object will not change since the plot objects already exist on the page. The server logic will have to be modified to make the plots reponsive to changes to the thershold inputs.

---
## Color the DE genes - server code

Multiple steps are required to do this:
* Since the plots will now be dependent on the filtering inputs, it's good practice to make the ggplot objects reactive expressions
* Add the inputs to the newly created *reactive* function that creates the ggplot object 
* Wrap with or add a pipe to a *bindEvent* function so that the *reactive* function with the plot takes a dependency on the button
* Use the reactive expression in the render function

```{r, echo=T, eval=F}
ma_plot_reac <- reactive({
    de_table %>%
      dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig)) +
      geom_point() +
      scale_x_log10() +
      scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })  %>%
    bindEvent(input$de_filter, ignoreNULL = FALSE)
  
    output$ma_plot = renderPlot({
      ma_plot_reac()
    }) 
```

---
## Color the DE genes in main app

```{r, echo=T, eval=T, out.width="75%"}


server_deColor = function(input, output) {
  output$all_data = renderDataTable({
    datatable(de_table,
              selection = "none",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, ignoreNULL = FALSE)

  output$de_data = renderDataTable({
    datatable(filtered_de(),
              selection = "none",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  ma_plot_reac <- reactive({
    de_table %>%
      dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig)) +
      geom_point() +
      scale_x_log10() +
      scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })  %>%
    bindEvent(input$de_filter, ignoreNULL = FALSE)
  
    output$ma_plot = renderPlot({
      ma_plot_reac()
    }) 
  
    volcano_plot_reac <- reactive({
      de_table %>%
        dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
        ggplot(de_table_wSig, aes(x = log2FoldChange, y = negLog10_pval, color = sig)) +
        geom_point() +
        scale_color_manual(name = "DE status", values = c("red", "grey")) +
        theme_bw() +
        ggtitle("Volcano plot")
    }) %>%
      bindEvent(input$de_filter, ignoreNULL = FALSE)
    
    
  output$volcano_plot = renderPlot({
    volcano_plot_reac()
  }) 
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

```

---
## Launch app with reactive plots

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_tab, server = server_deColor)
```

REPLACE WITH TAB APP!!!!!!!
 <img src="imgs/color_filter_nocheck.png"height="400" width="500">
 


---

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Advanced interactivity with tables and plots

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Advanced interactivity with tables and plots

---
"    
  )
  
}

```

## Selecting rows in a DT datatable

The datatable we are using from the DT package has a very useful functionality to enhance app interactivity. Rows can be selected and this informaiton is caputured in the app.

If we change the 'selection' argument to 'single' in the *datatable* function, then the user can click rows. Every time a row is clicked, shiny tracks this with a special input object. This object will always be the name of the table input with '_rows_selected' pasted onto the end. 


---
## Selecting rows in a DT datatable

In this simple app we print *input$all_data_rows_selected* and the gene in the selected row
```{r, echo=T, eval=F}
ui_rowSelect <- page_fluid(
  dataTableOutput(outputId = "all_data"),
  
  textOutput("selected_row_info")
)

server_rowSelect <- function(input, output){
  output$all_data = renderDataTable({
    datatable(de_table,
              selection = "single", #<<
              filter = 'top')
  })
  
  selected_row <- reactive({
    row_index <- input$all_data_rows_selected #<<
    de_table[row_index, ]
  })
  
  output$selected_row_info <- renderText({
    print(paste0("The selected gene is ", selected_row()$Symbol, " and the index of the selected row is ", input$all_data_rows_selected))
  })
}

```

---
## Selecting rows in a DT datatable


```{r, echo=T, eval=F}
shinyApp(ui_rowSelect, server_rowSelect)
```

.pull-left[
<img src="imgs/select_row1.png"height="350" width="500">
]

.pull-right[

<img src="imgs/select_row2.png"height="350" width="500">
]


---
## Pointer clicks on plots

Shiny also makes it easy to interact with plots. This cool feature can really enhance the user's ability to get information quickly from a simple looking app. 

The *plotOutput* function has a 'click' argument, and the string used (e.g. 'plot_click') becomes the name of an element in the input object that can be accessed in the server function. For example, *plotOutput("plot", click = "plot_click")* will result in 'input$plot_click' being available in server. 

In this case, 'input$plot_click' would be a list that contains the coordinates of the click. These coordinates can then be used in another Shiny function, *nearPoints*, which takes the clikc input object and the dataframe used for the plot, and returns the rows from the closest point (or points).

---
## Pointer clicks on plots

Here we show a table with the row of the clicked point in the server using the *nearPoints* function. The 'threshold' argument sets the distance (in y value space) from the point that is detected, and we also only return the closest point by setting 'maxpoints' to be one. 
```{r, echo=T, eval=T}
ui_pointClick <- page_fluid(
  plotOutput("volcano_plot", click = "volcano_click"), #<<
  
  tableOutput("selected_point_table"),
)

server_pointClick <- function(input, output){
  volcano_plot_reac <- reactive({
        ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
          geom_point() +
          theme_bw() 
    })
    
  output$volcano_plot = renderPlot(volcano_plot_reac()) 
  
  output$selected_point_table <- renderTable({
    nearPoints(de_table, input$volcano_click, threshold = 20, maxpoints = 1) #<<
  })
}

```

---
## Pointer clicks on plots


```{r, echo=T, eval=F}
shinyApp(ui_pointClick, server_pointClick)
```

<img src="imgs/clicked_points.png"height="450" width="850">


---
## Pointer brush on plots

A brush can be used in a similar way as the click. The 'brush' argument is set in *plotOutput* in the UI and we can then track the points that are in the selected area by rendering a table with the dataframe output from the *brushedPoints* function. 

```{r, echo=T, eval=T}
ui_pointBrush <- page_fluid(
  plotOutput("volcano_plot", brush = "volcano_brush"), #<<
  
  tableOutput("selected_brush_table")
)

server_pointBrush <- function(input, output){
  
  volcano_plot_reac <- reactive({
        ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval)) +
          geom_point() +
          theme_bw() 
    })
    
  output$volcano_plot = renderPlot(volcano_plot_reac()) 
  
  output$selected_brush_table <- renderTable({
    brushedPoints(de_table, input$volcano_brush) #<<
  })
}

```

---
## Pointer brush on plots


```{r, echo=T, eval=F}
shinyApp(ui_pointBrush, server_pointBrush)
```

<img src="imgs/brushed_points.png"height="400" width="500">

---
## Interactive plots with Plotly

```{r, echo=T, eval=T, message = F}
library(plotly)
ui_plotly <- page_fluid(
  plotlyOutput("volcano_plotly"), #<<
)

server_plotly <- function(input, output){
  volcano_plot_reac <- reactive({
        ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval, text = Symbol)) +
          geom_point() +
          theme_bw() 
    })
    
  output$volcano_plotly = renderPlotly(ggplotly(volcano_plot_reac())) #<< 

}

```

---
## Interactive plots with Plotly


```{r, echo=T, eval=F}
shinyApp(ui_plotly, server_plotly)
```

<img src="imgs/plotly.png"height="400" width="600">

---
## Get click info with Plotly

We can also pull out the row associated with the point that is clicked on when using plotly. Plotly has a function called *event_data* that returns a dataframe with the x and y values of the point that is highlighted when a cursor click occurs. 

The plot and click event can be linked with the 'source' argument given to both the *ggplotly* and *event_data* funcitons. We can use the x and y values returned by *event_data* to get the row of our table that represented the point that was clicked on. 


---
## Get click info with Plotly

```{r, echo=T, eval=T, message = F}
library(plotly)
ui_plotly <- page_fluid(
  plotlyOutput("volcano_plotly"),
  
  tableOutput("plotly_click_row")
)

server_plotly <- function(input, output){
  volcano_plot_reac <- reactive({
    ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval, text = Symbol)) + geom_point() + theme_bw() 
  })
  
  output$volcano_plotly = renderPlotly(ggplotly(volcano_plot_reac(), source = "volcano_plot"))  #<<
  
  clicked_row <- reactive({
    event <- event_data(event = "plotly_click", source = "volcano_plot") #<<
    if(!is.null(event) > 0){
      de_table %>% filter(log2FoldChange == event$x & negLog10_pval == event$y)
    }
  })
  
  output$plotly_click_row <- renderTable({
    clicked_row()
  })
}

```

---
## Interactive plots with Plotly


```{r, echo=T, eval=F}
shinyApp(ui_plotly, server_plotly)
```
<img src="imgs/plotly_clicked_point.png"height="400" width="500">

---

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Downloading and uploading files

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Downloading and uploading files

---
"    
  )
  
}

```

## Downloading plots - UI

Shiny makes it easy to download components of the app in the same way you would save any R object. To do this we use a special kind of button, called a *downloadButton*. 


```{r, echo=T, eval=T, message=F}
library(plotly)
ui_download <- page_fluid(
  plotlyOutput("volcano_plotly"),
  
  downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;") #<<
)

```

---
## In line CSS to style button

NOTE: the download button does not have a 'width' argument like the action button, so we set this by giving inline CSS commands to the 'style' argument. We won't get into CSS much in this course, but it can be a powerful way to highly customize any UI components in your Shiny app if you know how to use it. You will also likely often see people using it on message boards.

```{r, echo=T, eval=T, message=F}
library(plotly)
ui_download <- page_fluid(
  plotlyOutput("volcano_plotly"),
  
  downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;") #<<
)

```

---
## Downloading plots - server

In the server the output objects are paired with a *downloadHandler* function. This is a special kind of server function that will take two arguments that are both functions.
  * The 'filename' argument takes  no arguments and returns a string that will be the filename
  * The 'content' argument is a function that takes one argument named *file* that will be a temporary file path to write the file to, and the function contains code to generate and save the file.
  *Reactive values can be used inside of the 'content' function. 
  
```{r, echo=T, eval=T, message=F}
server_download <- function(input, output){
  volcano_plot_reac <- reactive(ggplot(de_table, aes(x = log2FoldChange, y = negLog10_pval, text = Symbol)) + geom_point() + theme_bw())
  
  output$volcano_plotly = renderPlotly(ggplotly(volcano_plot_reac(), source = "volcano_plot")) 
  
  output$download_volcano_plot <- downloadHandler( #<<
    filename = function() { #<<
      "volcanoplot.pdf" #<<
    }, content = function(file) { #<<
      ggsave(filename = file, plot = volcano_plot_reac()) #<<
    } #<<
  ) #<<
}
```

---
## Downloading plots - Launch app

```{r, echo=T, eval=F}
shinyApp(ui_download, server_download)
```

<img src="imgs/download_small.png"height="350" width="500">

---

## Add interactivity to main app

```{r, echo=T, eval=T}
ui_newPlots <- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.005),
    
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
 
        actionButton("de_filter", "Apply filter")
      ),
      
      layout_columns(
        navset_card_tab(
          title = "DE result tables",
          nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
          nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
        ),
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        # change to plotly and add download buttons to each card
        card(card_header("MA plot"),
             plotlyOutput("ma_plot"), 
             downloadButton("download_ma_plot", "Download MA plot", style = "width:40%;")), 
        card(card_header("Volcano plot"),
             plotlyOutput("volcano_plot"),
             downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;")), 
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)


```

---
## Add interactivity to main app - server

```{r, echo=T, eval=T, out.width="75%"}

server_newPlots = function(input, output) {
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  output$download_ma_plot <- downloadHandler(
    filename = function() {
      "maplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = ma_plot_reac())
    }
  )
  
  output$download_volcano_plot <- downloadHandler(
    filename = function() {
      "volcanoplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = volcano_plot_reac())
    }
  )
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  output$all_data = renderDataTable({
    datatable(de_table,
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  filtered_de <- reactive({
    de_table %>%
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, ignoreNULL = FALSE)

  output$de_data = renderDataTable({
    datatable(filtered_de(),
              selection = "single",
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
 ma_plot_reac <- reactive({
    de_table %>%
      dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig, label = Symbol)) + # add symbol as the label
      geom_point() +
      scale_x_log10() +
      scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") +
      theme_bw() +
      ggtitle("MA plot")
  })  %>%
    bindEvent(input$de_filter, ignoreNULL = FALSE)
  
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    # use 'renderPlotly' and wrap plot in 'ggplotly'
    output$ma_plot = renderPlotly({
      ggplotly(ma_plot_reac())
    }) 
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    volcano_plot_reac <- reactive({
      de_table %>%
        dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
        ggplot(aes(x = log2FoldChange, y = negLog10_pval, color = sig, label = Symbol)) + # add symbol as the label
        geom_point() +
        scale_color_manual(name = "DE status", values = c("red", "grey")) +
        theme_bw() +
        theme(legend.position="bottom", legend.text=element_text(size=12)) +
        ggtitle("Volcano plot")
    }) %>%
      bindEvent(input$de_filter, ignoreNULL = FALSE)
    
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  output$volcano_plot = renderPlotly({
    ggplotly(volcano_plot_reac())
  }) 
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

```

---
## Launch app

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_newPlots, server = server_newPlots)
```

---

## Upload a file

So far we have been starting with the same data. But this app would be more useful if you could use any file on your computer with differential expression results.

  
---
## Upload a file 

We can use the *fileInput* function in the UI to allow the user to input a file. The 'accept' argument to limit the type of file the user can try to upload.

```{r, echo=T, eval=T}
ui_upload <- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), #<<
  
  dataTableOutput(outputId = "all_data"),
)

server_upload <- function(input, output){
  de_table_in <- reactive({
    rio::import(input$de_file$datapath) %>% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data = renderDataTable({
    datatable(de_table_in(),
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })

}

```

---
## Upload a file 

The help page for fileInput (?fileInput) explains that once a file is loaded, then the value returned to the server is a data frame, and one of the columns is the path to the temporary file path where Shiny is holding the file.

This path is used below in the *de_table_in* reactive expression to read in the dataframe.  

```{r, echo=T, eval=T}
ui_upload <- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
  dataTableOutput(outputId = "all_data"),
)

server_upload <- function(input, output){
  de_table_in <- reactive({
    rio::import(input$de_file$datapath) %>%  #<<
      dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data = renderDataTable({
    datatable(de_table_in(),
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })

}

```

---
## Launch app

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_upload, server = server_upload)
```

<img src="imgs/upload_before_after.png"height="400" width="800">

---

## The req() function

In the previous UI, the user sees an error until a file is uploaded. This is because the file path is NULL and the *rio::import* function throws an error.

Shiny has a handy function *req* that can be added to a reactive context and the reactive or output function won't run if the value passed to *req* is NULL. We modify the reactive in the server function that reads in the table. 

```{r, echo=T, eval=T}

server_uploadReq <- function(input, output){
  
  de_table_in <- reactive({
    req(input$de_file)  #<<
    rio::import(input$de_file$datapath) %>%
      dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data = renderDataTable({
    datatable(de_table_in(),
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
}

```

---

## The req() function
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_upload, server = server_uploadReq)
```
<img src="imgs/addReq.png"height="400" width="800">

---

## Add upload to main app - UI

```{r, echo=T, eval=T}

ui_fileInput <- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
        # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.005),
    
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
 
        actionButton("de_filter", "Apply filter")
      ),
      
      layout_columns(
        navset_card_tab(
          title = "DE result tables",
          nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
          nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
        ),
        card(card_header("MA plot"),
             plotOutput("ma_plot"),
             downloadButton("download_ma_plot", "Download MA plot", style = "width:40%;")), 
        card(card_header("Volcano plot"),
             plotOutput("volcano_plot"),
             downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;")), 
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)
```

---

## Add upload to main app - server

The filtered table reactive and plot reactives use this table to apply the filtering cut offs, so we change these reactives to use this table and add de_table_in() to *bindEvent* so that they are updated when a new dataset is uploaded.
  
```{r, echo=T, eval=F}
# part of server function, not run in isolation...
filtered_de <- reactive({
    de_table_in() %>% #<<
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) #<<

```

```{r, echo=T, eval=F}
# part of server function, not run in isolation...
ma_plot_reac <- reactive({
    de_table_in() %>% #<<
      dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig, label = Symbol)) + geom_point() +
      scale_x_log10() + scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") + theme_bw() + ggtitle("MA plot")
  })  %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE)  #<<

```

---

## Add upload to main app - server

```{r, echo=T, eval=T, out.width="75%"}

server_fileInput = function(input, output) {

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  de_table_in <- reactive({
    req(input$de_file)
    rio::import(input$de_file$datapath) %>% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  output$download_ma_plot <- downloadHandler(
    filename = function() {
      "maplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = ma_plot_reac())
    }
  )
  
  output$download_volcano_plot <- downloadHandler(
    filename = function() {
      "volcanoplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = volcano_plot_reac())
    }
  )
  
  output$all_data = renderDataTable({
    datatable(de_table_in(), # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  filtered_de <- reactive({
    de_table_in() %>% # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  output$de_data = renderDataTable({
    datatable(filtered_de(), 
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
  ma_plot_reac <- reactive({
      de_table_in() %>% # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig, label = Symbol)) + geom_point() +
      scale_x_log10() + scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") + theme_bw() + ggtitle("MA plot")
  })  %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    output$ma_plot = renderPlot({
      ma_plot_reac()
    }) 
  
    volcano_plot_reac <- reactive({
        de_table_in() %>% # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
          ggplot(aes(x = log2FoldChange, y = negLog10_pval, color = sig)) +
          geom_point() +
          scale_color_manual(name = "DE status", values = c("red","grey"),) +
          ggtitle("Volcano plot")
      
    }) %>%
      bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
    output$volcano_plot = renderPlot({
      volcano_plot_reac()
    }) 
}

```

---
## Starting with an uploaded file

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_fileInput, server = server_fileInput)
```
<img src="imgs/mainApp_beforeUI.png"height="450" width="900">



---

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Improving app experience - dynamic UIs and user feedback

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Improving app experience - dynamic UIs and user feedback

---
"    
  )
  
}

```


## Using uiOutput/renderUI functions

.pull-left[
<img src="imgs/mainApp_beforeUI_preupload.png"height="450" width="400">
]

.pull-right[
We still have empty boxes when the app starts even though we don't have any data to fill that space. There are also buttons  that don't do anything because there is no data yet. This is likely to be confusing for a user.

A nice way to deal with this is the *uiOutput* function, which allows you to change the user interface **after the app is running** based on other inputs or code in the server.

So far our user interface is set up at the start and while the contents might change based on other reactives, we haven't been able to make new inputs or outputs after the app has been started.
]


---
## Using uiOutput/renderUI functions

 
.pull-right[
<img src="imgs/mainApp_beforeUI_filtBox.png"height="450" width="350">
]

.pull-left[
We could improve the flow of our app by making the filter inputs in the sidebar only appear once a user has loaded in a differential table. These filter inputs aren't relevant until the data is loaded, so we will only make them appear once the *de_table_in()* value is a dataframe, suggesting a file has been loaded and a table successfully read in.
]

---
## Using uiOutput/renderUI functions

The inputs for applying filters to our differential table are replaced with a *uiOutput* function call with an ID used in the output object in the server function This holds a location within the UI for us to eventually fill with server code.

```{r, echo=T, eval=T}
ui_renderUI <- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
   uiOutput("sidebar_filters_UI"), #<<
)

server_renderUI <- function(input, output){
  de_table_in <- reactive({
    req(input$de_file)
    rio::import(input$de_file$datapath) %>% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$sidebar_filters_UI <- renderUI({ 
    req(de_table_in())
      div(numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),
          numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
          actionButton("de_filter", "Apply filter"))
  })
}

```

---
## Using uiOutput/renderUI functions

These inputs are moved to the server within an output object paired with *renderUI* and are conditional on *de_table_in()* being a dataframe.

```{r, echo=T, eval=T}
ui_renderUI <- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
   uiOutput("sidebar_filters_UI"), 
)

server_renderUI <- function(input, output){
  de_table_in <- reactive({
    req(input$de_file)
    rio::import(input$de_file$datapath) %>% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$sidebar_filters_UI <- renderUI({ #<<
    req(de_table_in()) #<<
    div(numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),#<<
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),#<<
        actionButton("de_filter", "Apply filter"))#<<
  })#<<
}

```

---
## Using uiOutput/renderUI functions
EXPLAIN the DIV function!


---
## Launch uiOutput/renderUI app
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_renderUI, server = server_renderUI)
```

<img src="imgs/filterInputs_renderUI.png"height="350" width="800">


---
## Using uiOutput/renderUI functions

We will also hide the tables and plots since they are of no use until a file is uploaded. Empty elements can confuse the user and make it seem like something is wrong.

maybe include image of full app previously to show the empty boxes?

---
## Using uiOutput/renderUI functions

Conditional UIs can also take advantage of more complex if statements to determine what is shown. In the example below, if not data frame is loaded, then we output a message for the user and once data is loaded, the table is shown.

```{r, echo=T, eval=T}
ui_renderUI_table <- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
  
  uiOutput("all_data_UI")  #<<
)

server_renderUI_table <- function(input, output){
  de_table_in <- reactive({
    req(input$de_file)
    rio::import(input$de_file$datapath) %>% dplyr::mutate(negLog10_pval = -log10(pvalue))})
  
  output$all_data_UI <- renderUI({ #<<
    if(is.null(input$de_file)) { #<<
      div("You must load data!", style = "color: #273449; font-weight: bold;") #<<
    }else if(!is.null(de_table_in())){ #<<
      navset_card_tab(nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))) #<<
    } #<<
  }) #<<
  
  output$all_data = renderDataTable(datatable(de_table_in()))
}

```

---
## Launch uiOutput/renderUI app
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_renderUI_table , server = server_renderUI_table)
```

<img src="imgs/table_renderUI.png"height="350" width="800">

---
## Handling invalid input files

A common problem when allowing an input file is the likelihood a user uploads a file that causes an error in the app. Here we are looking for a table with speific columns, so we should confirm that the file is valid.

There are a few ways to do this in Shiny, and we will introduce a new Shiny function to handle this, the *validate* function.

```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_renderUI_table , server = server_renderUI_table)
```

<img src="imgs/bad_input_file.png"height="400" width="500">

---
## Use validate function to check input file

*Validate* prevents the alarming red error messages that are unhelpful to the user. This function can be used within a reactive expression, and the validation test is often called within a *need* function call.

*Need* takes an expression to evaluate, and if it is FALSE, then it will display a string provided in the 'message' argument in any output that depends on this reactive.

---
## Use validate function to check input file

We use *validate* in the server function when we read in the table. We check for the key columns in the table as we know that not having these columns will cause a downstream error in the app. 

```{r, echo=T, eval=T}
ui_validate_small <- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
  uiOutput("all_data_UI"))

server_validate_small <- function(input, output){
  de_table_in <- reactive({
    req(input$de_file)
    file_in <- rio::import(input$de_file$datapath)
    validate( #<<
      need(expr = all(c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj") %in% colnames(file_in)), #<<
           message = "You must have the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'")) #<<
    file_in %>% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data_UI <- renderUI({
    if(is.null(input$de_file)) {
      div("You must load data!", style = "color: #273449; font-weight: bold;")
    }else if(!is.null(de_table_in())){ 
      navset_card_tab(nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data")))
      }
  })
  
  output$all_data = renderDataTable(datatable(de_table_in()))
}

```

---
## Use validate function to check input file
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_validate_small, server = server_validate_small)
```
<img src="imgs/validate_small.png"height="300" width="800">

---
## Update main app

Recap of changes:
  * use *uiOutput/renderUI* to make the filter inputs and button from the sidebar conditional on the table being uploaded
  * use *uiOutput/renderUI* to display a message if there is not datapath loaded and only show the DE table one a valid table is read into the app.
  * add *validate* + *need* to the reactive expression where we read in the table from the user to make sure a valid inut file was used
  
  
---
## Update main app - UI

```{r, echo=T, eval=T}
ui_renderUIall <- page_navbar(
  title = "RNAseq tools",
  theme = custom_theme,
  nav_panel(
    title = "DE Analysis",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
        uiOutput("sidebar_filters_UI") # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      ),
      uiOutput("table_plots_UI"), # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    )
  ),
  nav_panel(
    title = "Next steps",
    "The next step in our analysis will be..."
  ),
  nav_spacer(),
  nav_menu(
    title = "Links",
    align = "right",
    nav_item(
      tags$a(
        shiny::icon("chart-simple"), "RU BRC - Learn more!",
        href = "https://rockefelleruniversity.github.io/",
        target = "_blank"
      )
    )
  )
)

```

---
## Update main app - server


```{r, echo=T, eval=T, out.width="75%"}

server_renderUIall = function(input, output) {
  
  de_table_in <- reactive({
    req(input$de_file)
    file_in <- rio::import(input$de_file$datapath)
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    validate(
      need(expr = all(c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj") %in% colnames(file_in)), 
           message = "You must have the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'")
    )
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    file_in %>% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data = renderDataTable({
    datatable(de_table_in(), filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  output$table_plots_UI <- renderUI({
    if(is.null(input$de_file)) { 
      layout_columns("No data has been loaded! Upload a DE table with the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'", style = "color: #273449; font-weight: bold;")
    }else if(!is.null(de_table_in())){ 
      layout_columns(
        navset_card_tab(
          title = "DE result tables",
          nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
          nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
        ),
        card(card_header("MA plot"),
             plotlyOutput("ma_plot"),
             downloadButton("download_ma_plot", "Download MA plot", style = "width:40%;")), 
        card(card_header("Volcano plot"),
             plotlyOutput("volcano_plot"),
             downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
      }
  })
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  output$sidebar_filters_UI <- renderUI({
    req(de_table_in())
      div(
        "DE filters",
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),
        
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
        
        actionButton("de_filter", "Apply filter")
      )
  })
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  filtered_de <- reactive({
    de_table_in() %>% 
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE)

  output$download_ma_plot <- downloadHandler(
    filename = function() {
      "maplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = ma_plot_reac())
    }
  )
  
  output$download_volcano_plot <- downloadHandler(
    filename = function() {
      "volcanoplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = volcano_plot_reac())
    }
  )
  
  output$de_data = renderDataTable({
    datatable(filtered_de(),
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
    ma_plot_reac <- reactive({
      de_table_in() %>% 
      dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig, label = Symbol)) + geom_point() +
      scale_x_log10() + scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") + theme_bw() + ggtitle("MA plot")
  })  %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 

    output$ma_plot = renderPlotly({
      ggplotly(ma_plot_reac())
    }) 
  
    volcano_plot_reac <- reactive({
        de_table_in() %>% 
          dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
          ggplot(aes(x = log2FoldChange, y = negLog10_pval, color = sig)) +
          geom_point() +
          scale_color_manual(name = "DE status", values = c("red","grey"),) +
          theme_bw() +
          ggtitle("Volcano plot")
      
    }) %>%
      bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 
  
    output$volcano_plot = renderPlotly({
      ggplotly(volcano_plot_reac())
    })
  
}

```

---
## Update main app - launch
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_renderUIall, server = server_renderUIall)
```


---

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Observers

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Observers

---
"    
  )
  
}

```

## Observers

Sometimes we might want our app to react to a change in an input, but we don't need to return a value like *reactive* or we don't need to change one of the outputs. Maybe we want to write to a database when a button is clicked, or notify the user that something has happened. 

Often the *observe* function is used for this purpose, to perform a side effect when an input changes.

Like the *reactive* function or an output, *observe* creates a reactive context that takes dependencies on inputs. Though unlike a reactive expression, an observer does not return a value and is eager in its evaluation, meaning it will evaluate the code every time an input it depends on changes. 

---

## Observers - notification for user

We will add a nice message for the user to notify them that a new data set has been loaded.

To do this we use the Shiny function *showNotification*. This takes text that will be the message, a duration in seconds for the notification to remain open, and a 'type' argument, which will control the color. We set 'duration' to be NULL, which means the user will have to click to close the notification, guaranteeing they will see it.

This function is within an *observe* function call in the server and takes a dependency on the input table with *bindEvent*. Notice we don't set the result to be a variable because an observer returns nothing, it just runs the code it contains. 

---

## Observers - notification for user

```{r, echo=T, eval=T}
ui_notify <- page_fluid(
  fileInput("de_file", "Upload a DE file", accept = c(".csv", ".tsv", "xlsx", "xls")), 
  uiOutput("all_data_UI"))

server_notify <- function(input, output){
  de_table_in <- reactive({
    req(input$de_file)
    file_in <- rio::import(input$de_file$datapath)
  })
  
  observe({ #<<
    showNotification("A new table has been loaded into the app!", duration = NULL, type = "message") #<<
  }) %>% #<<
    bindEvent(de_table_in()) #<<
  
  output$all_data_UI <- renderUI({
    if(is.null(input$de_file)) {
      div("Load data!", style = "color: #273449; font-weight: bold;")
    }else{ navset_card_tab(nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))) }
  })
  
  output$all_data = renderDataTable(datatable(de_table_in()))
}

```

---
## Observers - notification for user
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_notify, server = server_notify)
```

<img src="imgs/notify_small.png"height="350" width="700">


---

## Update app with notification - server 

```{r, echo=T, eval=T, out.width="75%"}

server_notify = function(input, output) {
  
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  observe({
      showNotification("A new table has been loaded into the app!", duration = NULL, type = "message")
  }) %>%
    bindEvent(de_table_in())
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  de_table_in <- reactive({
    req(input$de_file)
    file_in <- rio::import(input$de_file$datapath)
    validate(
      need(expr = all(c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj") %in% colnames(file_in)), 
           message = "You must have the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'")
    )
    file_in %>% dplyr::mutate(negLog10_pval = -log10(pvalue))
  })
  
  output$all_data = renderDataTable({
    datatable(de_table_in(), filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })

  output$table_plots_UI <- renderUI({
    if(is.null(input$de_file)) { 
      layout_columns("No data has been loaded! Upload a DE table with the following columns: 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'pvalue', 'padj'", style = "color: #273449; font-weight: bold;")
    }else if(!is.null(de_table_in())){ 
      layout_columns(
        navset_card_tab(
          title = "DE result tables",
          nav_panel(card_header("DEGs"), dataTableOutput(outputId = "de_data")),
          nav_panel(card_header("All genes"), dataTableOutput(outputId = "all_data"))
        ),
        card(card_header("MA plot"),
             plotlyOutput("ma_plot"),
             downloadButton("download_ma_plot", "Download MA plot", style = "width:40%;")), 
        card(card_header("Volcano plot"),
             plotlyOutput("volcano_plot"),
             downloadButton("download_volcano_plot", "Download volcano plot", style = "width:40%;")),
        col_widths = c(12,6,6), row_heights = c("750px", "500px")
      )
      }
  })
  
  output$sidebar_filters_UI <- renderUI({
    req(de_table_in())
      div(
        "DE filters",
        numericInput("padj_filter", label = "Cutoff for padj:", value = 0.05, min = 0, max = 1, step = 0.001),
        
        numericInput("lfc_filter", label = "Cutoff for log2 FC:", value = 1, min = 0, step = 0.1),
        
        actionButton("de_filter", "Apply filter")
      )
  })
  
  filtered_de <- reactive({
    de_table_in() %>% 
      dplyr::filter(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter)
  }) %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE)

  output$download_ma_plot <- downloadHandler(
    filename = function() {
      "maplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = ma_plot_reac())
    }
  )
  
  output$download_volcano_plot <- downloadHandler(
    filename = function() {
      "volcanoplot.pdf"
    },
    content = function(file) {
      ggsave(filename = file, plot = volcano_plot_reac())
    }
  )
  
  output$de_data = renderDataTable({
    datatable(filtered_de(),
              filter = 'top') %>%
      formatRound(columns = c("baseMean", "log2FoldChange", "lfcSE", "stat"), digits = 3) %>%
      formatSignif(columns = c("pvalue", "padj"), digits = 3)
  })
  
    ma_plot_reac <- reactive({
      de_table_in() %>% 
      dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
      ggplot(aes(x = baseMean, y = log2FoldChange, color = sig, label = Symbol)) + geom_point() +
      scale_x_log10() + scale_color_manual(name = "DE status", values = c("red", "grey")) +
      xlab("baseMean (log scale)") + theme_bw() + ggtitle("MA plot")
  })  %>%
    bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 

    output$ma_plot = renderPlotly({
      ggplotly(ma_plot_reac())
    }) 
  
    volcano_plot_reac <- reactive({
        de_table_in() %>% 
          dplyr::mutate(sig = ifelse(padj < input$padj_filter & abs(log2FoldChange) > input$lfc_filter, "DE", "Not_DE")) %>%
          ggplot(aes(x = log2FoldChange, y = negLog10_pval, color = sig)) +
          geom_point() +
          scale_color_manual(name = "DE status", values = c("red","grey"),) +
          theme_bw() +
          ggtitle("Volcano plot")
      
    }) %>%
      bindEvent(input$de_filter, de_table_in(), ignoreNULL = FALSE) 
  
    output$volcano_plot = renderPlotly({
      ggplotly(volcano_plot_reac())
    })
}

```

---

## Notification for user - app
```{r, echo=T, eval=F, out.width="75%"}
shinyApp(ui = ui_renderUIall, server = server_notify)
```

---
use observer to let user enter file name for plots?

also can use observer when you introduce the update* series of functions
---



# other ideas for later on

* reactiveValues()
* valueBox?
* intorduce ways to include custom HTML
* custom CSS?
* publishing to shinyapps.io
* debugging?
* mention shiny in python?


---
## Further Resources

* [Mastering Shiny book](https://mastering-shiny.org/index.html)
* [More widgets](https://dreamrs.github.io/shinyWidgets/)


---
## Exercises

Exercise on Reproducibility in R can be found [here](../../exercises/exercises/Docker_exercise.html)


---
## Contact

Any suggestions, comments, edits or questions (about content or the slides themselves) please reach out to our [GitHub](https://github.com/RockefellerUniversity/Intro_to_Shiny/issues) and raise an issue.


--
## Exercises
The following few slides show you how to structure exercise slides.

We often have several exercise slides per session. So you can just copy and paste and change the directory to the appropriate name. All 3 file types are made from you single exercise Rmd. 

---
## Time for an exercise!

??? exercise description here?? [here](../../exercises/exercises/MyExercise1_exercises.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/MyExercise1_answers.html)

R code for solutions can be found [here](../../exercises/answers/MyExercise1_answers.R)

## Exercise again

So we can have some more sections here describing some new important topic

Then more exercises

---
## Time for an exercise!

??? exercise description here?? [here](../../exercises/exercises/MyExercise2_exercises.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/MyExercise2_answers.html)

R code for solutions can be found [here](../../exercises/answers/MyExercise2_answers.R)
